~ $ xmodmap thesis.git/config/switched.modmap 
~ $ find ./ -name "*.wav"
find: .//.cpan/build/File-Copy-Recursive-0.38-s5znBG: Permission denied
  C-c C-c
~ $ cd ~/Desktop/
~/Desktop $ scp joecorneli.jpg ccg@ccg01.doc.gold.ac.uk:/home/ccg/public_html/images/joecorneli.jpg
The authenticity of host 'ccg01.doc.gold.ac.uk (158.223.58.201)' can't be established.
RSA key fingerprint is 15:1c:2b:26:0b:d4:9d:5f:9d:30:4e:f1:fc:6e:ba:65.
Are you sure you want to continue connecting (yes/no)? yes

Warning: Permanently added 'ccg01.doc.gold.ac.uk,158.223.58.201' (RSA) to the list of known hosts.
ccg@ccg01.doc.gold.ac.uk's password: 
Permission denied, please try again.
ccg@ccg01.doc.gold.ac.uk's password: 
joecorneli.jpg                                100%  218KB 217.8KB/s   00:00    
~/Desktop $ cd ~/thesis.git/questions/
~/thesis.git/questions $ pdflatex answers.tex
This is pdfTeX, Version 3.1415926-1.40.11 (TeX Live 2010)
 restricted \write18 enabled.
entering extended mode
(./answers.tex
LaTeX2e <2009/09/24>
Babel <v3.8l> and hyphenation patterns for english, dumylang, nohyphenation, ge
rman-x-2009-06-19, ngerman-x-2009-06-19, afrikaans, ancientgreek, ibycus, arabi
c, armenian, basque, bulgarian, catalan, pinyin, coptic, croatian, czech, danis
h, dutch, ukenglish, usenglishmax, esperanto, estonian, ethiopic, farsi, finnis
h, french, galician, german, ngerman, swissgerman, monogreek, greek, hungarian,
 icelandic, assamese, bengali, gujarati, hindi, kannada, malayalam, marathi, or
iya, panjabi, tamil, telugu, indonesian, interlingua, irish, italian, kurmanji,
 lao, latin, latvian, lithuanian, mongolian, mongolianlmc, bokmal, nynorsk, pol
ish, portuguese, romanian, russian, sanskrit, serbian, slovak, slovenian, spani
sh, swedish, turkish, turkmen, ukrainian, uppersorbian, welsh, loaded.
(/usr/local/texlive/2010/texmf-dist/tex/latex/memoir/memoir.cls
Document Class: memoir 2011/03/06 v3.6j configurable book, report, article docu
ment class
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/ifpdf.sty)
(/usr/local/texlive/2010/texmf-dist/tex/generic/ifxetex/ifxetex.sty)
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/ifluatex.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/etex-pkg/etex.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/memoir/mem12.clo)
(/usr/local/texlive/2010/texmf-dist/tex/latex/memoir/mempatch.sty))
(/usr/local/texlive/2010/texmf-dist/tex/generic/babel/babel.sty
(/usr/local/texlive/2010/texmf-dist/tex/generic/babel/english.ldf
(/usr/local/texlive/2010/texmf-dist/tex/generic/babel/babel.def))
(/usr/local/texlive/2010/texmf-dist/tex/generic/babel/english.ldf))
(/usr/local/texlive/2010/texmf-dist/tex/latex/csquotes/csquotes.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/etoolbox/etoolbox.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/graphics/keyval.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/csquotes/csquotes.def)
(/usr/local/texlive/2010/texmf-dist/tex/latex/csquotes/csquotes.cfg))
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsfonts/amssymb.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsfonts/amsfonts.sty))
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsmath/amsmath.sty
For additional information on amsmath, use the `?' option.
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsmath/amstext.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsmath/amsgen.sty))
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsmath/amsbsy.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsmath/amsopn.sty))
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/biblatex.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/logreq/logreq.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/logreq/logreq.def))
(/usr/local/texlive/2010/texmf-dist/tex/latex/base/ifthen.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/url/url.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/blx-compat.def)
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/biblatex.def)
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex-apa/apa.bbx
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/bbx/standard.bbx))
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex-apa/apa.cbx)
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/biblatex.cfg)

! Package biblatex Error: Conflicting options (maxcitenames/mincitenames).

See the biblatex package documentation for explanation.
Type  H <return>  for immediate help.
 ...                                              
                                                  
l.9838 \blx@processoptions
                          
? 
) (/usr/local/texlive/2010/texmf-dist/tex/latex/xcolor/xcolor.sty
(/usr/local/texlive/2010/texmf-dist/tex/latex/latexconfig/color.cfg)
(/usr/local/texlive/2010/texmf-dist/tex/latex/pdftex-def/pdftex.def
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/infwarerr.sty)
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/ltxcmds.sty)))
(/usr/local/texlive/2010/texmf-dist/tex/latex/hyperref/hyperref.sty
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/hobsub-hyperref.sty
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/hobsub-generic.sty))
(/usr/local/texlive/2010/texmf-dist/tex/latex/oberdiek/kvoptions.sty)
(/usr/local/texlive/2010/texmf-dist/tex/latex/hyperref/pd1enc.def)
(/usr/local/texlive/2010/texmf-dist/tex/latex/latexconfig/hyperref.cfg))
(/usr/local/texlive/2010/texmf-dist/tex/latex/memoir/memhfixc.sty)

Package hyperref Message: Driver (autodetected): hpdftex.

(/usr/local/texlive/2010/texmf-dist/tex/latex/hyperref/hpdftex.def
(/usr/local/texlive/2010/texmf-dist/tex/latex/oberdiek/rerunfilecheck.sty))
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex-apa/american-apa.lbx
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/lbx/american.lbx
(/usr/local/texlive/2010/texmf-dist/tex/latex/biblatex/lbx/english.lbx)))
(./answers.aux) (./answers.bbl)
(/usr/local/texlive/2010/texmf-dist/tex/context/base/supp-pdf.mkii
[Loading MPS to PDF converter (version 2006.09.02).]
) (/usr/local/texlive/2010/texmf-dist/tex/latex/hyperref/nameref.sty
(/usr/local/texlive/2010/texmf-dist/tex/generic/oberdiek/gettitlestring.sty))
Redoing nameref's sectioning
Redoing nameref's label
(./answers.out) (./answers.out)
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsfonts/umsa.fd)
(/usr/local/texlive/2010/texmf-dist/tex/latex/amsfonts/umsb.fd) [1{/usr/local/t
exlive/2010/texmf-var/fonts/map/pdftex/updmap/pdftex.map}] [2] [3] [4] [5]
[6] [7] [8] [9] [10] [11] [12]
Overfull \hbox (1.05028pt too wide) in paragraph at lines 164--165
[]\OT1/cmr/m/n/12 Speaking of col-lab-o-ra-tion, I re-cently learned about the 
the-sis of Jonathan
[13] [14] [15] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27]
[28] (./answers.aux)

Package rerunfilecheck Warning: File `answers.out' has changed.
(rerunfilecheck)                Rerun to get outlines right
(rerunfilecheck)                or use package `bookmark'.


Package biblatex Warning: Please rerun LaTeX.
(biblatex)                Page breaks have changed.

 )</usr/local/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmbx12.pfb
></usr/local/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmr12.pfb><
/usr/local/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmr17.pfb></u
sr/local/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmr7.pfb></usr/
local/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmr8.pfb></usr/loc
al/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmsl12.pfb></usr/loca
l/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmti12.pfb></usr/local
/texlive/2010/texmf-dist/fonts/type1/public/amsfonts/cm/cmtt10.pfb></usr/local/
texlive/2010/texmf-dist/fonts/type1/public/amsfonts/symbols/msbm10.pfb>
Output written on answers.pdf (28 pages, 173949 bytes).
Transcript written on answers.log.
~/thesis.git/questions $ evince answers.pdf &
[1] 26348
~/thesis.git/questions $ bash: evince: command not found

[1]+  Exit 127                evince answers.pdf
~/thesis.git/questions $ ope answers.pdf &
[1] 26350
~/thesis.git/questions $ bash: ope: command not found
ope answers.pdf &
[2] 26351
[1]   Exit 127                ope answers.pdf
~/thesis.git/questions $ bash: ope: command not found

[2]+  Exit 127                ope answers.pdf
~/thesis.git/questions $ open answers.pdf &
[1] 26352
~/thesis.git/questions $ cd 
[1]+  Done                    open answers.pdf  (wd: ~/thesis.git/questions)
(wd now: ~)
~ $ wget http://decipher.open.ac.uk/SemRecommender/recommendSections/cache?dossierID=http://decipher-research.eu/dossiers/1533
--2013-11-13 11:10:33--  http://decipher.open.ac.uk/SemRecommender/recommendSections/cache?dossierID=http://decipher-research.eu/dossiers/1533
Resolving decipher.open.ac.uk... 137.108.64.23
Connecting to decipher.open.ac.uk|137.108.64.23|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [application/xml]
Saving to: `cache?dossierID=http:%2F%2Fdecipher-research.eu%2Fdossiers%2F1533'

    [ <=>                                   ] 2,968       --.-K/s   in 0s      

2013-11-13 11:10:34 (8.93 MB/s) - `cache?dossierID=http:%2F%2Fdecipher-research.eu%2Fdossiers%2F1533' saved [2968]

~ $ wget http://decipher.open.ac.uk/SemRecommender/recommendSections/cache?dossierID=http://decipher-research.eu/dossiers/1533 -O bla.xml
--2013-11-13 11:10:41--  http://decipher.open.ac.uk/SemRecommender/recommendSections/cache?dossierID=http://decipher-research.eu/dossiers/1533
Resolving decipher.open.ac.uk... 137.108.64.23
Connecting to decipher.open.ac.uk|137.108.64.23|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [application/xml]
Saving to: `bla.xml'

    [ <=>                                   ] 2,968       --.-K/s   in 0s      

2013-11-13 11:10:41 (12.4 MB/s) - `bla.xml' saved [2968]

~ $
~ $ git clone https://github.com/git/git
Cloning into git...
error: Failed connect to github.com:443; Connection refused while accessing https://github.com/git/git/info/refs

fatal: HTTP request failed
~ $ git clone https://github.com/git/git
Cloning into git...
error: Could not resolve host: github.com (Could not contact DNS servers) while accessing https://github.com/git/git/info/refs

fatal: HTTP request failed
~ $ git clone https://github.com/git/git
Cloning into git...
error: Could not resolve host: github.com (Could not contact DNS servers) while accessing https://github.com/git/git/info/refs

fatal: HTTP request failed
~ $ git clone https://github.com/git/git
Cloning into git...
error: Could not resolve host: github.com (Could not contact DNS servers) while accessing https://github.com/git/git/info/refs

fatal: HTTP request failed
~ $ git clone https://github.com/git/git
Cloning into git...
error: Could not resolve host: github.com (Could not contact DNS servers) while accessing https://github.com/git/git/info/refs

fatal: HTTP request failed
~ $ git clone https://github.com/git/git
Cloning into git...
remote: Finding bitmap roots...        
remote: Counting objects: 164782, done.        
remote: Compressing objects: 100% (45872/45872), done.        
remote: Total 164782 (delta 118632), reused 162987 (delta 116936)        
Receiving objects: 100% (164782/164782), 51.53 MiB | 3.37 MiB/s, done.
Resolving deltas: 100% (118632/118632), done.
~ $ chmod +x test-driven-development-script.el 
~ $ ./test-driven-development-script.el 
bash: ./test-driven-development-script.el: emacs: bad interpreter: No such file or directory
~ $ which emacs
/usr/local/bin/emacs
~ $ /usr/local/bin/emacs --version
GNU Emacs 24.3.1
Copyright (C) 2013 Free Software Foundation, Inc.
GNU Emacs comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of Emacs
under the terms of the GNU General Public License.
For more information about these matters, see the file named COPYING.
~ $ ./test-driven-development-script.el 

3
~ $ ./test-driven-development-script.el 

3
~ $ ./test-driven-development-script.el 
Symbol's function definition is void: return
~ $ ./test-driven-development-script.el 
No catch for tag: --cl-block-nil--, 3
~ $ ./test-driven-development-script.el 
No catch for tag: --cl-block-nil--, 3
~ $ emacs --help
Usage: emacs [OPTION-OR-FILENAME]...

Run Emacs, the extensible, customizable, self-documenting real-time
display editor.  The recommended way to start Emacs for normal editing
is with no options at all.

Run M-x info RET m emacs RET m emacs invocation RET inside Emacs to
read the main documentation for these command-line arguments.

Initialization options:

--batch                     do not do interactive display; implies -q
--chdir DIR                 change to directory DIR
--daemon                    start a server in the background
--debug-init                enable Emacs Lisp debugger for init file
--display, -d DISPLAY       use X server DISPLAY
--no-desktop                do not load a saved desktop
--no-init-file, -q          load neither ~/.emacs nor default.el
--no-shared-memory, -nl     do not use shared memory
--no-site-file              do not load site-start.el
--no-site-lisp, -nsl        do not add site-lisp directories to load-path
--no-splash                 do not display a splash screen on startup
--no-window-system, -nw     do not communicate with X, ignoring $DISPLAY
--quick, -Q                 equivalent to:
                              -q --no-site-file --no-site-lisp --no-splash
--script FILE               run FILE as an Emacs Lisp script
--terminal, -t DEVICE       use DEVICE for terminal I/O
--user, -u USER             load ~USER/.emacs instead of your own

Action options:

FILE                    visit FILE using find-file
+LINE                   go to line LINE in next FILE
+LINE:COLUMN            go to line LINE, column COLUMN, in next FILE
--directory, -L DIR     add DIR to variable load-path
--eval EXPR             evaluate Emacs Lisp expression EXPR
--execute EXPR          evaluate Emacs Lisp expression EXPR
--file FILE             visit FILE using find-file
--find-file FILE        visit FILE using find-file
--funcall, -f FUNC      call Emacs Lisp function FUNC with no arguments
--insert FILE           insert contents of FILE into current buffer
--kill                  exit without asking for confirmation
--load, -l FILE         load Emacs Lisp FILE using the load function
--visit FILE            visit FILE using find-file

Display options:

--background-color, -bg COLOR   window background color
--basic-display, -D             disable many display features;
                                  used for debugging Emacs
--border-color, -bd COLOR       main border color
--border-width, -bw WIDTH       width of main border
--color, --color=MODE           override color mode for character terminals;
                                  MODE defaults to `auto', and
                                  can also be `never', `always',
                                  or a mode name like `ansi8'
--cursor-color, -cr COLOR       color of the Emacs cursor indicating point
--font, -fn FONT                default font; must be fixed-width
--foreground-color, -fg COLOR   window foreground color
--fullheight, -fh               make the first frame high as the screen
--fullscreen, -fs               make the first frame fullscreen
--fullwidth, -fw                make the first frame wide as the screen
--maximized, -mm                make the first frame maximized
--geometry, -g GEOMETRY         window geometry
--no-bitmap-icon, -nbi          do not use picture of gnu for Emacs icon
--iconic                        start Emacs in iconified state
--internal-border, -ib WIDTH    width between text and main border
--line-spacing, -lsp PIXELS     additional space to put between lines
--mouse-color, -ms COLOR        mouse cursor color in Emacs window
--name NAME                     title for initial Emacs frame
--no-blinking-cursor, -nbc      disable blinking cursor
--reverse-video, -r, -rv        switch foreground and background
--title, -T TITLE               title for initial Emacs frame
--vertical-scroll-bars, -vb     enable vertical scroll bars
--xrm XRESOURCES                set additional X resources
--parent-id XID                 set parent window
--help                          display this help and exit
--version                       output version information and exit

You can generally also specify long option names with a single -; for
example, -batch as well as --batch.  You can use any unambiguous
abbreviation for a --option.

Various environment variables and window system resources also affect
Emacs' operation.  See the main documentation.

Report bugs to bug-gnu-emacs@gnu.org.  First, please see the Bugs
section of the Emacs manual or the file BUGS.
~ $ ./test-driven-development-script.el 
No catch for tag: --cl-block-nil--, 3
~ $ ./test-driven-development-script.el 
No catch for tag: --cl-block-nil--, 3
~ $ ./test-driven-development-script.el 
~ $ ./test-driven-development-script.el 
~ $ ./test-driven-development-script.el 

3
~ $ ./test-driven-development-script.el 
3~ $ ./test-driven-development-script.el 
Invalid format operation %a
~ $ ./test-driven-development-script.el 
"3\\n"~ $ ./test-driven-development-script.el 
"3
"~ $ ./test-driven-development-script.el 
~ $ ./test-driven-development-script.el 

"3
"
~ $ ./test-driven-development-script.el 
3
~ $ ./test-driven-development-script.el 
~ $ ./test-driven-development-script.el 
3
~ $ ./test-driven-development-script.el 
3
~ $ ./test-driven-development-script.el 2>&1
3
~ $ ./test-driven-development-script.el 1>&2
3
~ $ ./test-driven-development-script.el 2> out
3
~ $ cat out
~ $ ./test-driven-development-script.el 2> out
3
~ $ cat out
~ $ ./test-driven-development-script.el 2> out
3
~ $ cat out
Wrong number of arguments: format, 0
~ $ ./test-driven-development-script.el 
3
~ $ echo $?
113
~ $ git hooks help
git: 'hooks' is not a git command. See 'git --help'.
~ $ git hooks --help
WARNING: terminal is not fully functional
-  (press RETURN) 
GITHOOKS(5)                                              Git Manual                                             GITHOOKS(5)

NAME
       githooks - Hooks used by git

SYNOPSIS
       $GIT_DIR/hooks/*

DESCRIPTION
       Hooks are little scripts you can place in $GIT_DIR/hooks directory to trigger action at certain points. When git
       init is run, a handful of example hooks are copied into the hooks directory of the new repository, but by default
       they are all disabled. To enable a hook, rename it by removing its .sample suffix.

           Note
           It is also a requirement for a given hook to be executable. However - in a freshly initialized repository - the
           .sample files are executable by default.

       This document describes the currently defined hooks.

HOOKS
   applypatch-msg
       This hook is invoked by git am script. It takes a single parameter, the name of the file that holds the proposed
       commit log message. Exiting with non-zero status causes git am to abort before applying the patch.
:
: 
       The hook is allowed to edit the message file in place, and can be used to normalize the message into some project
       standard format (if the project has one). It can also be used to refuse the commit after inspecting the message
       file.

       The default applypatch-msg hook, when enabled, runs the commit-msg hook, if the latter is enabled.

   pre-applypatch
       This hook is invoked by git am. It takes no parameter, and is invoked after the patch is applied, but before a
       commit is made.

       If it exits with non-zero status, then the working tree will not be committed after applying the patch.

       It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.

       The default pre-applypatch hook, when enabled, runs the pre-commit hook, if the latter is enabled.

   post-applypatch
       This hook is invoked by git am. It takes no parameter, and is invoked after the patch is applied and a commit is
       made.

       This hook is meant primarily for notification, and cannot affect the outcome of git am.

   pre-commit
       This hook is invoked by git commit, and can be bypassed with --no-verify option. It takes no parameter, and is
: 
       invoked before obtaining the proposed commit log message and making a commit. Exiting with non-zero status from this
       script causes the git commit to abort.

       The default pre-commit hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the
       commit when such a line is found.

       All the git commit hooks are invoked with the environment variable GIT_EDITOR=: if the command will not bring up an
       editor to modify the commit message.

   prepare-commit-msg
       This hook is invoked by git commit right after preparing the default log message, and before the editor is started.

       It takes one to three parameters. The first is the name of the file that contains the commit log message. The second
       is the source of the commit message, and can be: message (if a -m or -F option was given); template (if a -t option
       was given or the configuration option commit.template is set); merge (if the commit is a merge or a .git/MERGE_MSG
       file exists); squash (if a .git/SQUASH_MSG file exists); or commit, followed by a commit SHA1 (if a -c, -C or
       --amend option was given).

       If the exit status is non-zero, git commit will abort.

       The purpose of the hook is to edit the message file in place, and it is not suppressed by the --no-verify option. A
       non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit
       hook.
:
: 
       The sample prepare-commit-msg hook that comes with git comments out the Conflicts: part of a merge's commit message.

   commit-msg
       This hook is invoked by git commit, and can be bypassed with --no-verify option. It takes a single parameter, the
       name of the file that holds the proposed commit log message. Exiting with non-zero status causes the git commit to
       abort.

       The hook is allowed to edit the message file in place, and can be used to normalize the message into some project
       standard format (if the project has one). It can also be used to refuse the commit after inspecting the message
       file.

       The default commit-msg hook, when enabled, detects duplicate "Signed-off-by" lines, and aborts the commit if one is
       found.

   post-commit
       This hook is invoked by git commit. It takes no parameter, and is invoked after a commit is made.

       This hook is meant primarily for notification, and cannot affect the outcome of git commit.

   pre-rebase
       This hook is called by git rebase and can be used to prevent a branch from getting rebased.

   post-checkout
       This hook is invoked when a git checkout is run after having updated the worktree. The hook is given three
: 
       parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag
       indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a
       file from the index, flag=0). This hook cannot affect the outcome of git checkout.

       It is also run after git clone, unless the --no-checkout (-n) option is used. The first parameter given to the hook
       is the null-ref, the second the ref of the new HEAD and the flag is always 1.

       This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if
       different, or set working dir metadata properties.

   post-merge
       This hook is invoked by git merge, which happens when a git pull is done on a local repository. The hook takes a
       single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot
       affect the outcome of git merge and is not executed, if the merge failed due to conflicts.

       This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata
       associated with the working tree (eg: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an
       example of how to do this.

   pre-receive
       This hook is invoked by git-receive-pack on the remote repository, which happens when a git push is done on a local
       repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit
       status determines the success or failure of the update.
:
: 
       This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives
       on standard input a line of the format:

           <old-value> SP <new-value> SP <ref-name> LF

       where <old-value> is the old object name stored in the ref, <new-value> is the new object name to be stored in the
       ref and <ref-name> is the full name of the ref. When creating a new ref, <old-value> is 40 0.

       If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of
       individual refs can still be prevented by the update hook.

       Both standard output and standard error output are forwarded to git send-pack on the other end, so you can simply
       echo messages for the user.

   update
       This hook is invoked by git-receive-pack on the remote repository, which happens when a git push is done on a local
       repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status
       determines the success or failure of the ref update.

       The hook executes once for each ref to be updated, and takes three parameters:

       o   the name of the ref being updated,

       o   the old object name stored in the ref,
: 

       o   and the new objectname to be stored in the ref.

       A zero exit from the update hook allows the ref to be updated. Exiting with a non-zero status prevents
       git-receive-pack from updating that ref.

       This hook can be used to prevent forced update on certain refs by making sure that the object name is a commit
       object that is a descendant of the commit object named by the old object name. That is, to enforce a "fast-forward
       only" policy.

       It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would
       end up firing one e-mail per ref when used naively, though. The post-receive hook is more suited to that.

       Another use suggested on the mailing list is to use this hook to implement access control which is finer grained
       than the one based on filesystem group.

       Both standard output and standard error output are forwarded to git send-pack on the other end, so you can simply
       echo messages for the user.

       The default update hook, when enabled--and with hooks.allowunannotated config option unset or set to false--prevents
       unannotated tags to be pushed.

   post-receive
       This hook is invoked by git-receive-pack on the remote repository, which happens when a git push is done on a local
: 
       repository. It executes on the remote repository once after all the refs have been updated.

       This hook executes once for the receive operation. It takes no arguments, but gets the same information as the
       pre-receive hook does on its standard input.

       This hook does not affect the outcome of git-receive-pack, as it is called after the real work is done.

       This supersedes the post-update hook in that it gets both old and new values of all the refs in addition to their
       names.

       Both standard output and standard error output are forwarded to git send-pack on the other end, so you can simply
       echo messages for the user.

       The default post-receive hook is empty, but there is a sample script post-receive-email provided in the
       contrib/hooks directory in git distribution, which implements sending commit emails.

   post-update
       This hook is invoked by git-receive-pack on the remote repository, which happens when a git push is done on a local
       repository. It executes on the remote repository once after all the refs have been updated.

       It takes a variable number of parameters, each of which is the name of ref that was actually updated.

       This hook is meant primarily for notification, and cannot affect the outcome of git-receive-pack.
:
: 
       The post-update hook can tell what are the heads that were pushed, but it does not know what their original and
       updated values are, so it is a poor place to do log old..new. The post-receive hook does get both original and
       updated values of the refs. You might consider it instead if you need them.

       When enabled, the default post-update hook runs git update-server-info to keep the information used by dumb
       transports (e.g., HTTP) up-to-date. If you are publishing a git repository that is accessible via HTTP, you should
       probably enable this hook.

       Both standard output and standard error output are forwarded to git send-pack on the other end, so you can simply
       echo messages for the user.

   pre-auto-gc
       This hook is invoked by git gc --auto. It takes no parameter, and exiting with non-zero status from this script
       causes the git gc --auto to abort.

   post-rewrite
       This hook is invoked by commands that rewrite commits (git commit --amend, git-rebase; currently git-filter-branch
       does not call it!). Its first argument denotes the command it was invoked by: currently one of amend or rebase.
       Further command-dependent arguments may be passed in the future.

       The hook receives a list of the rewritten commits on stdin, in the format

           <old-sha1> SP <new-sha1> [ SP <extra-info> ] LF
:
: 
       The extra-info is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands
       pass any extra-info.

       The hook always runs after the automatic note copying (see "notes.rewrite.<command>" in linkgit:git-config.txt) has
       happened, and thus has access to these notes.

       The following command-specific comments apply:

       rebase
           For the squash and fixup operation, all commits that were squashed are listed as being rewritten to the squashed
           commit. This means that there will be several lines sharing the same new-sha1.

           The commits are guaranteed to be listed in the order that they were processed by rebase.

GIT
       Part of the git(1) suite

Git 1.7.4.3                                              04/03/2011                                             GITHOOKS(5)
(END) q
~ $ ~ $ ./test-driven-development-script.el 
nil
~ $ ./test-driven-development-script.el abc def ghk
(abc def ghk)
~ $ ./test-driven-development-script.el "abc" def ghk
(abc def ghk)
~ $ ./test-driven-development-script.el \"ABC\" def ghk
("ABC" def ghk)
~ $ mkdir test-driven-development
~ $ cd test-driven-development
~/test-driven-development $ git init
Initialized empty Git repository in /Users/jac2349/test-driven-development/.git/
~/test-driven-development $ git add README
~/test-driven-development $ git commit -m "Adding README"
(.git/COMMIT_EDITMSG message)

Loading vc-git...
[master (root-commit) 7f79bed] Adding README
 1 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 README
~/test-driven-development $ git log
WARNING: terminal is not fully functional
-  (press RETURN) 
commit 7f79bedf385fb69b78920b71eb2f5ed56436d35f
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:43:29 2013 +0000

    Adding README
~/test-driven-development $ ~/test-driven-development $ git commit --help
WARNING: terminal is not fully functional
-  (press RETURN) 
GIT-COMMIT(1)                                            Git Manual                                           GIT-COMMIT(1)

NAME
       git-commit - Record changes to the repository

SYNOPSIS
       git commit [-a | --interactive] [-s] [-v] [-u<mode>] [--amend] [--dry-run]
                  [(-c | -C | --fixup | --squash) <commit>] [-F <file> | -m <msg>]
                  [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify]
                  [-e] [--author=<author>] [--date=<date>] [--cleanup=<mode>]
                  [--status | --no-status] [-i | -o] [--] [<file>...]

DESCRIPTION
       Stores the current contents of the index in a new commit along with a log message from the user describing the
       changes.

       The content to be added can be specified in several ways:

        1. by using git add to incrementally "add" changes to the index before using the commit command (Note: even
           modified files must be "added");

        2. by using git rm to remove files from the working tree and the index, again before using the commit command;

        3. by listing files as arguments to the commit command, in which case the commit will ignore changes staged in the
: 
           index, and instead record the current content of the listed files (which must already be known to git);

        4. by using the -a switch with the commit command to automatically "add" changes from all known files (i.e. all
           files that are already listed in the index) and to automatically "rm" files in the index that have been removed
           from the working tree, and then perform the actual commit;

        5. by using the --interactive switch with the commit command to decide one by one which files should be part of the
           commit, before finalizing the operation. Currently, this is done by invoking git add --interactive.

       The --dry-run option can be used to obtain a summary of what is included by any of the above for the next commit by
       giving the same set of parameters (options and paths).

       If you make a commit and then find a mistake immediately after that, you can recover from it with git reset.

OPTIONS
       -a, --all
           Tell the command to automatically stage files that have been modified and deleted, but new files you have not
           told git about are not affected.

       -C <commit>, --reuse-message=<commit>
           Take an existing commit object, and reuse the log message and the authorship information (including the
           timestamp) when creating the commit.

       -c <commit>, --reedit-message=<commit>
: 
           Like -C, but with -c the editor is invoked, so that the user can further edit the commit message.

       --fixup=<commit>
           Construct a commit message for use with rebase --autosquash. The commit message will be the subject line from
           the specified commit with a prefix of "fixup! ". See git-rebase(1) for details.

       --squash=<commit>
           Construct a commit message for use with rebase --autosquash. The commit message subject line is taken from the
           specified commit with a prefix of "squash! ". Can be used with additional commit message options (-m/-c/-C/-F).
           See git-rebase(1) for details.

       --reset-author
           When used with -C/-c/--amend options, declare that the authorship of the resulting commit now belongs of the
           committer. This also renews the author timestamp.

       --short
           When doing a dry-run, give the output in the short-format. See git-status(1) for details. Implies --dry-run.

       --porcelain
           When doing a dry-run, give the output in a porcelain-ready format. See git-status(1) for details. Implies
           --dry-run.

       -z
           When showing short or porcelain status output, terminate entries in the status output with NUL, instead of LF.
: 
           If no format is given, implies the --porcelain output format.

       -F <file>, --file=<file>
           Take the commit message from the given file. Use - to read the message from the standard input.

       --author=<author>
           Override the commit author. Specify an explicit author using the standard A U Thor <author@example.com[1]>
           format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that
           author (i.e. rev-list --all -i --author=<author>); the commit author is then copied from the first such commit
           found.

       --date=<date>
           Override the author date used in the commit.

       -m <msg>, --message=<msg>
           Use the given <msg> as the commit message.

       -t <file>, --template=<file>
           Use the contents of the given file as the initial version of the commit message. The editor is invoked and you
           can make subsequent changes. If a message is specified using the -m or -F options, this option has no effect.
           This overrides the commit.template configuration variable.

       -s, --signoff
           Add Signed-off-by line by the committer at the end of the commit log message.
: 

       -n, --no-verify
           This option bypasses the pre-commit and commit-msg hooks. See also githooks(5).

       --allow-empty
           Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command
           prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM
           interface scripts.

       --allow-empty-message
           Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a
           commit with an empty commit message without using plumbing commands like git-commit-tree(1).

       --cleanup=<mode>
           This option sets how the commit message is cleaned up. The <mode> can be one of verbatim, whitespace, strip, and
           default. The default mode will strip leading and trailing empty lines and #commentary from the commit message
           only if the message is to be edited. Otherwise only whitespace removed. The verbatim mode does not change
           message at all, whitespace removes just leading/trailing whitespace lines and strip removes both whitespace and
           commentary.

       -e, --edit
           The message taken from file with -F, command line with -m, and from file with -C are usually used as the commit
           log message unmodified. This option lets you further edit the message taken from these sources.
:
: 
       --amend
           Used to amend the tip of the current branch. Prepare the tree object you would want to replace the latest commit
           as usual (this includes the usual -i/-o and explicit paths), and the commit log editor is seeded with the commit
           message from the tip of the current branch. The commit you create replaces the current tip -- if it was a merge,
           it will have the parents of the current tip as parents -- so the current top commit is discarded.

           It is a rough equivalent for:

                       $ git reset --soft HEAD^
                       $ ... do something else to come up with the right tree ...
                       $ git commit -c ORIG_HEAD

           but can be used to amend a merge commit.

           You should understand the implications of rewriting history if you amend a commit that has already been
           published. (See the "RECOVERING FROM UPSTREAM REBASE" section in git-rebase(1).)

       -i, --include
           Before making a commit out of staged contents so far, stage the contents of paths given on the command line as
           well. This is usually not what you want unless you are concluding a conflicted merge.

       -o, --only
           Make a commit only from the paths specified on the command line, disregarding any contents that have been staged
           so far. This is the default mode of operation of git commit if any paths are given on the command line, in which
: 
           case this option can be omitted. If this option is specified together with --amend, then no paths need to be
           specified, which can be used to amend the last commit without committing changes that have already been staged.

       -u[<mode>], --untracked-files[=<mode>]
           Show untracked files.

           The mode parameter is optional (defaults to all), and is used to specify the handling of untracked files; when
           -u is not used, the default is normal, i.e. show untracked files and directories.

           The possible options are:

           o    no - Show no untracked files

           o    normal - Shows untracked files and directories

           o    all - Also shows individual files in untracked directories.

               The default can be changed using the status.showUntrackedFiles configuration variable documented in git-
               config(1).

       -v, --verbose
           Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message
           template. Note that this diff output doesn't have its lines prefixed with #.
:
: 
       -q, --quiet
           Suppress commit summary message.

       --dry-run
           Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be
           left uncommitted and paths that are untracked.

       --status
           Include the output of git-status(1) in the commit message template when using an editor to prepare the commit
           message. Defaults to on, but can be used to override configuration variable commit.status.

       --no-status
           Do not include the output of git-status(1) in the commit message template when using an editor to prepare the
           default commit message.

       --
           Do not interpret any more arguments as options.

       <file>...
           When files are given on the command line, the command commits the contents of the named files, without recording
           the changes already staged. The contents of these files are also staged for the next commit on top of what have
           been staged before.

DATE FORMATS
:q
~/test-driven-development $ ~/test-driven-development $ git add README
~/test-driven-development $ git commit -m "Update README"
args: nil
[master 4eb2be3] Update README
 1 files changed, 3 insertions(+), 1 deletions(-)
~/test-driven-development $ git log --help
WARNING: terminal is not fully functional
-  (press RETURN) 
GIT-LOG(1)                                               Git Manual                                              GIT-LOG(1)

NAME
       git-log - Show commit logs

SYNOPSIS
       git log [<options>] [<since>..<until>] [[--] <path>...]

DESCRIPTION
       Shows the commit logs.

       The command takes options applicable to the git rev-list command to control what is shown and how, and options
       applicable to the git diff-* commands to control how the changes each commit introduces are shown.

OPTIONS
       -<n>
           Limits the number of commits to show.

       <since>..<until>
           Show only commits between the named two commits. When either <since> or <until> is omitted, it defaults to HEAD,
           i.e. the tip of the current branch. For a more complete list of ways to spell <since> and <until>, see
           gitrevisions(7).

       --follow
: q
           Continue listing the history of a file beyond renames (works only for a single file).

       --no-decorate, --decorate[=short|full|no]
           Print out the ref names of any commits that are shown. If short is specified, the ref name prefixes refs/heads/,
           refs/tags/ and refs/remotes/ will not be printed. If full is specified, the full ref name (including prefix)
           will be printed. The default option is short.

       --source
           Print out the ref name given on the command line by which each commit was reached.

       --full-diff
           Without this flag, "git log -p <path>..." shows commits that touch the specified paths, and diffs about the same
           specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that
           "<path>..." limits only commits, and doesn't limit diff for those commits.

           Note that this affects all diff-based output types, e.g. those produced by --stat etc.

       --log-size
           Before the log message print out its size in bytes. Intended mainly for porcelain tools consumption. If git is
           unable to produce a valid value size is set to zero. Note that only message is considered, if also a diff is
           shown its size is not included.

       [--] <path>...
~/test-driven-development $ ~/test-driven-development $ git commit -a -m "Update README"
args: nil
0[master c44435f] Update README
 1 files changed, 3 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Update README"
args: nil
log: commit 23e058ebdd8611281c7a2d01eefe71b85cb4fddf
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:49:34 2013 +0000

    Update README

[master 23e058e] Update README
 1 files changed, 3 insertions(+), 1 deletions(-)
~/test-driven-development $ ln -s
ln: missing file operand
Try `ln --help' for more information.
~/test-driven-development $ ln --help
Usage: ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)
  or:  ln [OPTION]... TARGET                  (2nd form)
  or:  ln [OPTION]... TARGET... DIRECTORY     (3rd form)
  or:  ln [OPTION]... -t DIRECTORY TARGET...  (4th form)
In the 1st form, create a link to TARGET with the name LINK_NAME.
In the 2nd form, create a link to TARGET in the current directory.
In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.
Create hard links by default, symbolic links with --symbolic.
When creating hard links, each TARGET must exist.  Symbolic links
can hold arbitrary text; if later resolved, a relative link is
interpreted in relation to its parent directory.

Mandatory arguments to long options are mandatory for short options too.
      --backup[=CONTROL]      make a backup of each existing destination file
  -b                          like --backup but does not accept an argument
  -d, -F, --directory         allow the superuser to attempt to hard link
                                directories (note: will probably fail due to
                                system restrictions, even for the superuser)
  -f, --force                 remove existing destination files
  -i, --interactive           prompt whether to remove destinations
  -L, --logical               make hard links to symbolic link references
  -n, --no-dereference        treat destination that is a symlink to a
                                directory as if it were a normal file
  -P, --physical              make hard links directly to symbolic links
  -s, --symbolic              make symbolic links instead of hard links
  -S, --suffix=SUFFIX         override the usual backup suffix
  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to create
                                the links
  -T, --no-target-directory   treat LINK_NAME as a normal file
  -v, --verbose               print name of each linked file
      --help     display this help and exit
      --version  output version information and exit

The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

Using -s ignores -L and -P.  Otherwise, the last option specified controls
behavior when the source is a symbolic link, defaulting to -L.

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups

Report ln bugs to bug-coreutils@gnu.org
GNU coreutils home page: <http://www.gnu.org/software/coreutils/>
General help using GNU software: <http://www.gnu.org/gethelp/>
Report ln translation bugs to <http://translationproject.org/team/>
For complete documentation, run: info coreutils 'ln invocation'
~/test-driven-development $ ls
README  README~  post-commit
~/test-driven-development $ rm .git/hooks/post-commit
~/test-driven-development $ ln -s post-commit ./.git/hooks/
~/test-driven-development $ ls .git/hooks/post-commit
ls: cannot access .git/hooks/post-commit: Too many levels of symbolic links
~/test-driven-development $ ln -s post-commit ./.git/hooks/post-commit
~/test-driven-development $ ln -s ../../post-commit ./.git/hooks/post-commit
~/test-driven-development $ git add post-commit
~/test-driven-development $ git commit -m "Add sample hook content"
[master 4d2b129] Add sample hook content
 1 files changed, 37 insertions(+), 0 deletions(-)
 create mode 100644 post-commit
~/test-driven-development $ chmod +x post-commit
~/test-driven-development $ git commit -a -m "Update README"
args: nil
log: commit 2bbe541ed8da693185cae925fd1fcc6f3c7c4a29
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:54:51 2013 +0000

    Update README

[master 2bbe541] Update README
 1 files changed, 17 insertions(+), 8 deletions(-)
 rewrite README (72%)
 mode change 100644 => 100755 post-commit
~/test-driven-development $ git commit -a -m "Update code"
log: commit 12f6e28a0d9bcd6ada23490686431ede82989b2a
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:55:26 2013 +0000

    Update code

[master 12f6e28] Update code
 1 files changed, 3 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "OK, things are working now"
log: commit cfbf286709f503e5788bc8d60fc36237473073da
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:56:36 2013 +0000

    OK, things are working now

[master cfbf286] OK, things are working now
 1 files changed, 5 insertions(+), 3 deletions(-)
~/test-driven-development $ git commit -a -m "Getting a sha1"
End of file during parsing: /Users/jac2349/test-driven-development/.git/hooks/post-commit
[master 6ed4469] Getting a sha1
 1 files changed, 8 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Getting a sha1 for real"
Not enough arguments for format string
[master 96adf30] Getting a sha1 for real
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "Getting a sha1 for real and printing it"
sha1: nil
[master 203226d] Getting a sha1 for real and printing it
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "different access method"
sha1: nil
[master 8824e38] different access method
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "fix typo"
sha1: 741d32ca745d05cc1ede7cd1fcfa14594bcb7599
[master 741d32c] fix typo
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "Try to show added lines"
sha1: 0fd1236fd0b4fd0920ca06593b674a53f62b5798
Symbol's value as variable is void: history
[master 0fd1236] Try to show added lines
 1 files changed, 18 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "Try to show added lines"
sha1: 5329459aa4deb2e2b95809b211c7e4cddb0f4cc2
added lines:
 nil
[master 5329459] Try to show added lines
 1 files changed, 8 insertions(+), 13 deletions(-)
~/test-driven-development $ git commit -a -m "Fix temp buffer"
sha1: b115cce5b28598fa798fa861a2739ed138b1faae
added lines:
 nil
[master b115cce] Fix temp buffer
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git show b115cce5b28598fa798fa861a2739ed138b1faae
WARNING: terminal is not fully functional
-  (press RETURN) 
commit b115cce5b28598fa798fa861a2739ed138b1faae
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:08:04 2013 +0000

    Fix temp buffer

diff --git a/post-commit b/post-commit
index e2a52de..5284501 100755
--- a/post-commit
+++ b/post-commit
@@ -13,7 +13,7 @@
 
 (defun get-diff-per-commit (sha1)
   (with-temp-buffer
-    (shell-command (concat "git show " sha1))
+    (insert (shell-command-to-string (concat "git show " sha1)))
     ;; for now, we will just look at the text that is added, not
     ;; text that is deleted
     (keep-lines "^+" (point-min) (point-max))
~/test-driven-development $ ~/test-driven-development $ git commit -a -m "return string"
sha1: e9f7d984f94b46209bf6651ad821101bff98c32b
added lines:
  b/post-commit
      (replace-match "" nil nil))
    (buffer-substring-no-properties (point-min) (point-max))))

[master e9f7d98] return string
 1 files changed, 2 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Change name of function"
sha1: dc91e37b376d8754a607bd4ee53f739e6768aa4b
added lines:
  b/post-commit
(defun get-added-lines-per-commit (sha1)
  (princ (format "added lines:\n %s\n"  (get-added-lines-per-commit sha1))))

[master dc91e37] Change name of function
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git show dc91e37b376d8754a607bd4ee53f739e6768aa4b
WARNING: terminal is not fully functional
-  (press RETURN) 
commit dc91e37b376d8754a607bd4ee53f739e6768aa4b
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:09:48 2013 +0000

    Change name of function

diff --git a/post-commit b/post-commit
index 7226e5e..eafff24 100755
--- a/post-commit
+++ b/post-commit
@@ -11,7 +11,7 @@
 ;; - We don't use args for this particular script
 ; (princ (format "args: %s\n" command-line-args-left))
 
-(defun get-diff-per-commit (sha1)
+(defun get-added-lines-per-commit (sha1)
   (with-temp-buffer
     (insert (shell-command-to-string (concat "git show " sha1)))
     ;; for now, we will just look at the text that is added, not
@@ -30,7 +30,7 @@
   
 
   (princ (format "sha1: %s\n"  sha1))
-  (princ (format "added lines:\n %s\n"  (get-diff-per-commit sha1))))
:q
~/test-driven-development $ ~/test-driven-development $ git commit -a -m "Don't return the name of the changed file"
sha1: 25211e250deff8d8debf6e5a54d560391556eda1
added lines:
     (keep-lines "^+[^+][^+]" (point-min) (point-max))

[master 25211e2] Don't return the name of the changed file
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Also print names of modified files"
sha1: b5e65bb1401ea87c6304e7be3bd600b2f126eedc
added lines:
   "Given a commit SHA1, return the lines that have been changed."
(defun get-modified-files-per-commit (sha1)
  "Given a commit SHA1, return the names of the modified files."
  (with-temp-buffer
    (insert (shell-command-to-string (concat "git show " sha1)))
    ;; for now, we will just look at the text that is added, not
    ;; text that is deleted
    (keep-lines "^+++" (point-min) (point-max))
    (goto-char (point-min))
    (while (re-search-forward "^+++" nil t)
      (replace-match "" nil nil))
    (buffer-substring-no-properties (point-min) (point-max))))

 (let* ((orig-commit-message (shell-command-to-string "git log -1"))
  (princ (format "added lines:\n %s\n"  (get-added-lines-per-commit sha1)))
  (princ (format "modified files:\n %s\n"  (get-modified-files-per-commit sha1))))

modified files:
  b/post-commit
  "Given a commit SHA1, return the lines that have been changed."
(defun get-modified-files-per-commit (sha1)
  "Given a commit SHA1, return the names of the modified files."
  (with-temp-buffer
    (insert (shell-command-to-string (concat "git show " sha1)))
    ;; for now, we will just look at the text that is added, not
    ;; text that is deleted
    (keep-lines "^+++" (point-min) (point-max))
    (goto-char (point-min))
    (while (re-search-forward "^+++" nil t)
      (replace-match "" nil nil))
    (buffer-substring-no-properties (point-min) (point-max))))

  (princ (format "added lines:\n %s\n"  (get-added-lines-per-commit sha1)))
  (princ (format "modified files:\n %s\n"  (get-modified-files-per-commit sha1))))

[master b5e65bb] Also print names of modified files
 1 files changed, 15 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "fix regexp"
sha1: b1d4109f66cd91c7268585d878a4173e0765d7b8
added lines:
     (keep-lines "^+\+\+" (point-min) (point-max))
    (while (re-search-forward "^\+\+\+" nil t)

modified files:
  b/post-commit
    (keep-lines "^+\+\+" (point-min) (point-max))
    (while (re-search-forward "^\+\+\+" nil t)

[master b1d4109] fix regexp
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "fix regexp some more"
sha1: f42ec16766cf396fe6680693375899d0d742f23a
added lines:
     (keep-lines "^\+[^+][^+]" (point-min) (point-max))
    (while (re-search-forward "^\+" nil t)
    (keep-lines "^\+\+\+" (point-min) (point-max))

modified files:
  b/post-commit
    (keep-lines "^\+[^+][^+]" (point-min) (point-max))
    (while (re-search-forward "^\+" nil t)
    (keep-lines "^\+\+\+" (point-min) (point-max))

[master f42ec16] fix regexp some more
 1 files changed, 3 insertions(+), 3 deletions(-)
~/test-driven-development $ git show f42ec16766cf396fe6680693375899d0d742f23a
WARNING: terminal is not fully functional
-  (press RETURN) 
commit f42ec16766cf396fe6680693375899d0d742f23a
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:14:47 2013 +0000

    fix regexp some more

diff --git a/post-commit b/post-commit
index 950b66e..3e718e3 100755
--- a/post-commit
+++ b/post-commit
@@ -17,9 +17,9 @@
     (insert (shell-command-to-string (concat "git show " sha1)))
     ;; for now, we will just look at the text that is added, not
     ;; text that is deleted
-    (keep-lines "^+[^+][^+]" (point-min) (point-max))
+    (keep-lines "^\+[^+][^+]" (point-min) (point-max))
     (goto-char (point-min))
-    (while (re-search-forward "^+" nil t)
+    (while (re-search-forward "^\+" nil t)
       (replace-match "" nil nil))
     (buffer-substring-no-properties (point-min) (point-max))))
 
@@ -29,7 +29,7 @@
     (insert (shell-command-to-string (concat "git show " sha1)))
: 
     ;; for now, we will just look at the text that is added, not
     ;; text that is deleted
-    (keep-lines "^+\+\+" (point-min) (point-max))
+    (keep-lines "^\+\+\+" (point-min) (point-max))
     (goto-char (point-min))
     (while (re-search-forward "^\+\+\+" nil t)
       (replace-match "" nil nil))
(END)  
(END) q
~/test-driven-development $ ~/test-driven-development $ git commit -a -m "fix regexp some more"
sha1: a11d96c38776a4e3115e08026196d4f2e4ec8c37
added lines:
     (keep-lines "^\\+\\+\\+" (point-min) (point-max))
    (while (re-search-forward "^\\+\\+\\+" nil t)

modified files:
  b/post-commit

[master a11d96c] fix regexp some more
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "fix regexp some more, I think I have it now"
sha1: 7130a10baa52baafff648d81e01bc9910f7ec3ac
added lines:
     (keep-lines "^\\+[^+][^+]" (point-min) (point-max))
    (while (re-search-forward "^\\+" nil t)

modified files:
  b/post-commit

[master 7130a10] fix regexp some more, I think I have it now
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "Just the filename"
sha1: e79f4de517a906d45f5e28872b315378f90d3179
added lines:
     (while (re-search-forward "^\\+\\+\\+ b/" nil t)

modified files:
 post-commit

[master e79f4de] Just the filename
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git show help
fatal: ambiguous argument 'help': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions
~/test-driven-development $ git show --help
WARNING: terminal is not fully functional
-  (press RETURN) 
GIT-SHOW(1)                                              Git Manual                                             GIT-SHOW(1)

NAME
       git-show - Show various types of objects

SYNOPSIS
       git show [options] <object>...

DESCRIPTION
       Shows one or more objects (blobs, trees, tags and commits).

       For commits it shows the log message and textual diff. It also presents the merge commit in a special format as
       produced by git diff-tree --cc.

       For tags, it shows the tag message and the referenced objects.

       For trees, it shows the names (equivalent to git ls-tree with --name-only).

       For plain blobs, it shows the plain contents.

       The command takes options applicable to the git diff-tree command to control how the changes the commit introduces
       are shown.

       This manual page describes only the most frequently used options.
: 

OPTIONS
       <object>...
           The names of objects to show. For a more complete list of ways to spell object names, see "SPECIFYING REVISIONS"
           section in gitrevisions(7).

       --pretty[=<format>], --format=<format>
           Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short,
           medium, full, fuller, email, raw and format:<string>. See the "PRETTY FORMATS" section for some additional
           details for each format. When omitted, the format defaults to medium.

           Note: you can specify the default pretty format in the repository configuration (see git-config(1)).

       --abbrev-commit
           Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default
           number of digits can be specified with "--abbrev=<n>" (which also modifies diff output, if it is displayed).

           This should make "--pretty=oneline" a whole lot more readable for people using 80-column terminals.

       --oneline
           This is a shorthand for "--pretty=oneline --abbrev-commit" used together.

       --encoding[=<encoding>]
           The commit objects record the encoding used for the log message in their encoding header; this option can be
: 
           used to tell the command to re-code the commit log message in the encoding preferred by the user. For non
           plumbing commands this defaults to UTF-8.

       --no-notes, --show-notes[=<ref>]
           Show the notes (see git-notes(1)) that annotate the commit, when showing the commit log message. This is the
           default for git log, git show and git whatchanged commands when there is no --pretty, --format nor --oneline
           option is given on the command line.

           With an optional argument, add this ref to the list of notes. The ref is taken to be in refs/notes/ if it is not
           qualified.

       --[no-]standard-notes
           Enable or disable populating the notes ref list from the core.notesRef and notes.displayRef variables (or
           corresponding environment overrides). Enabled by default. See git-config(1).

PRETTY FORMATS
       If the commit is a merge, and if the pretty-format is not oneline, email or raw, an additional line is inserted
       before the Author: line. This line begins with "Merge: " and the sha1s of ancestral commits are printed, separated
       by spaces. Note that the listed commits may not necessarily be the list of the direct parent commits if you have
       limited your view of history: for example, if you are only interested in changes related to a certain directory or
       file.

       There are several built-in formats, and you can define additional formats by setting a pretty.<name> config option
       to either another format name, or a format: string, as described below (see git-config(1)). Here are the details of
: 
       the built-in formats:

       o    oneline

               <sha1> <title line>

           This is designed to be as compact as possible.

       o    short

               commit <sha1>
               Author: <author>

               <title line>

       o    medium

               commit <sha1>
               Author: <author>
               Date:   <author date>

               <title line>

               <full commit message>
: 

       o    full

               commit <sha1>
               Author: <author>
               Commit: <committer>

               <title line>

               <full commit message>

       o    fuller

               commit <sha1>
               Author:     <author>
               AuthorDate: <author date>
               Commit:     <committer>
               CommitDate: <committer date>

               <title line>

               <full commit message>

       o    email
: 

               From <sha1> <date>
               From: <author>
               Date: <author date>
               Subject: [PATCH] <title line>

               <full commit message>

       o    raw

           The raw format shows the entire commit exactly as stored in the commit object. Notably, the SHA1s are displayed
           in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent
           commits, without taking grafts nor history simplification into account.

       o    format:<string>

           The format:<string> format allows you to specify which information you want to show. It works a little bit like
           printf format, with the notable exception that you get a newline with %n instead of \n.

           E.g, format:"The author of %h was %an, %ar%nThe title was >>%s<<%n" would show something like this:

               The author of fe6e0ee was Junio C Hamano, 23 hours ago
               The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<
:
: 
           The placeholders are:

           o    %H: commit hash

           o    %h: abbreviated commit hash

           o    %T: tree hash

           o    %t: abbreviated tree hash

           o    %P: parent hashes

           o    %p: abbreviated parent hashes

           o    %an: author name

           o    %aN: author name (respecting .mailmap, see git-shortlog(1) or git-blame(1))

           o    %ae: author email

           o    %aE: author email (respecting .mailmap, see git-shortlog(1) or git-blame(1))

           o    %ad: author date (format respects --date= option)
:
: 
           o    %aD: author date, RFC2822 style

           o    %ar: author date, relative

           o    %at: author date, UNIX timestamp

           o    %ai: author date, ISO 8601 format

           o    %cn: committer name

           o    %cN: committer name (respecting .mailmap, see git-shortlog(1) or git-blame(1))

           o    %ce: committer email

           o    %cE: committer email (respecting .mailmap, see git-shortlog(1) or git-blame(1))

           o    %cd: committer date

           o    %cD: committer date, RFC2822 style

           o    %cr: committer date, relative

           o    %ct: committer date, UNIX timestamp
:
: 
           o    %ci: committer date, ISO 8601 format

           o    %d: ref names, like the --decorate option of git-log(1)

           o    %e: encoding

           o    %s: subject

           o    %f: sanitized subject line, suitable for a filename

           o    %b: body

           o    %B: raw body (unwrapped subject and body)

           o    %N: commit notes

           o    %gD: reflog selector, e.g., refs/stash@{1}

           o    %gd: shortened reflog selector, e.g., stash@{1}

           o    %gs: reflog subject

           o    %Cred: switch color to red
:
: 
           o    %Cgreen: switch color to green

           o    %Cblue: switch color to blue

           o    %Creset: reset color

           o    %C(...): color specification, as described in color.branch.* config option

           o    %m: left, right or boundary mark

           o    %n: newline

           o    %%: a raw %

           o    %x00: print a byte from a hex code

           o    %w([<w>[,<i1>[,<i2>]]]): switch line wrapping, like the -w option of git-shortlog(1).

           Note
           Some placeholders may depend on other options given to the revision traversal engine. For example, the %g*
           reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d
           placeholder will use the "short" decoration format if --decorate was not already provided on the command line.

       If you add a + (plus sign) after % of a placeholder, a line-feed is inserted immediately before the expansion if and
: 
       only if the placeholder expands to a non-empty string.

       If you add a - (minus sign) after % of a placeholder, line-feeds that immediately precede the expansion are deleted
       if and only if the placeholder expands to an empty string.

       If you add a ` ` (space) after % of a placeholder, a space is inserted immediately before the expansion if and only
       if the placeholder expands to a non-empty string.

       o    tformat:

           The tformat: format works exactly like format:, except that it provides "terminator" semantics instead of
           "separator" semantics. In other words, each commit has the message terminator character (usually a newline)
           appended, rather than a separator placed between entries. This means that the final entry of a single-line
           format will be properly terminated with a new line, just as the "oneline" format does. For example:

               $ git log -2 --pretty=format:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973 -- NO NEWLINE

               $ git log -2 --pretty=tformat:%h 4da45bef \
                 | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
               4da45be
               7134973
: 

           In addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For
           example, these two are equivalent:

               $ git log -2 --pretty=tformat:%h 4da45bef
               $ git log -2 --pretty=%h 4da45bef

EXAMPLES
       git show v1.0.0
           Shows the tag v1.0.0, along with the object the tags points at.

       git show v1.0.0^{tree}
           Shows the tree pointed to by the tag v1.0.0.

       git show -s --format=%s v1.0.0^{commit}
           Shows the subject of the commit pointed to by the tag v1.0.0.

       git show next~10:Documentation/README
           Shows the contents of the file Documentation/README as they were current in the 10th last commit of the branch
           next.

       git show master:Makefile master:t/Makefile
           Concatenates the contents of said Makefiles in the head of the branch master.
:
: 
DISCUSSION
       At the core level, git is character encoding agnostic.

       o   The pathnames recorded in the index and in the tree objects are treated as uninterpreted sequences of non-NUL
           bytes. What readdir(2) returns are what are recorded and compared with the data git keeps track of, which in
           turn are expected to be what lstat(2) and creat(2) accepts. There is no such thing as pathname encoding
           translation.

       o   The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the
           core level.

       o   The commit log messages are uninterpreted sequences of non-NUL bytes.

       Although we encourage that the commit log messages are encoded in UTF-8, both the core and git Porcelain are
       designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use
       legacy encodings, git does not forbid it. However, there are a few things to keep in mind.

        1.  git commit and git commit-tree issues a warning if the commit log message given to it does not look like a
           valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to
           have i18n.commitencoding in .git/config file, like this:

               [i18n]
                       commitencoding = ISO-8859-1
:
: 
           Commit objects created with the above setting record the value of i18n.commitencoding in its encoding header.
           This is to help other people who look at them later. Lack of this header implies that the commit log message is
           encoded in UTF-8.

        2.  git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the
           log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with
           i18n.logoutputencoding in .git/config file, like this:

               [i18n]
                       logoutputencoding = ISO-8859-1

           If you do not have this configuration variable, the value of i18n.commitencoding is used instead.

       Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the
       commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.

AUTHOR
       Written by Linus Torvalds <torvalds@osdl.org[1]> and Junio C Hamano <gitster@pobox.com[2]>. Significantly enhanced
       by Johannes Schindelin <Johannes.Schindelin@gmx.de[3]>.

DOCUMENTATION
       Documentation by David Greaves, Petr Baudis and the git-list <git@vger.kernel.org[4]>.

GIT
: 
       Part of the git(1) suite

NOTES
        1. torvalds@osdl.org
           mailto:torvalds@osdl.org

        2. gitster@pobox.com
           mailto:gitster@pobox.com

        3. Johannes.Schindelin@gmx.de
           mailto:Johannes.Schindelin@gmx.de

        4. git@vger.kernel.org
           mailto:git@vger.kernel.org

Git 1.7.4.3                                              04/03/2011                                             GIT-SHOW(1)
(END) q
~/test-driven-development $ ~/test-driven-development $ ls
README  README~  post-commit  post-commit~
~/test-driven-development $ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	#post-commit#
#	.#post-commit
#	README~
#	post-commit~
#	test-driven-development.el
nothing added to commit but untracked files present (use "git add" to track)
~/test-driven-development $ git add test-driven-development.el
~/test-driven-development $ git commit -m "Add the test-driven-development.el file"
sha1: 3f0dfec2af8dac3f915809decb7c587c21ae3ff2
added lines:
 ;;; test-driven-development.el - sketch use of the FACE model to record creative progress
;;; Documentation: General Overview:
;; The idea in this file is to use some variant of test driven development
;; (for now, within the framework describe in ~/emacs-24.3/info/ert.info)
;; as a way to keep track of an evolving model of a codebase.  It is build around
;; a set of tests that instantiate the FACE model of computational creativity.
;; This model is specified, at the outline level, as follows:
;;
;;    F = framing
;;    A = aesthetic
;;    C = concept
;;    E = Example / Expression (?)
;;
;; Potential uses of this system:
;; 
;; - In a given instantiation of this programme, we might model something like the
;; growth of the APM XI corpus through the addition of new examples and new
;; relationships between elements.
;;
;; - In general, like with other kinds of test-driven development, we might write
;; the tests "first" and use these to specify objectives as a "development
;; roadmap" i.e. when those tests are passing, a given phase of the project is
;; complete.
;;
;; Note that it seems vastly easier to build a particular instantiation of the
;; FACE model than it is to build a general-purpose test that would always say
;; "you have added a new concept" or "you have added a new aesthetic-method".
;;
;; Instead of having a fully general model that works every time, we could instead
;; come up with a type-theoretic treatment of the FACE schema, so that we could
;; check whether a given system implements a test for a given facet of FACE.
;;
;; If we go that route, it might make more sense to implement the test system in
;; Haskell rather than LISP... but of course we actually want to be flexible, so
;; we need to maintain a general sense of a test "implementing" a given type of
;; test, across different programming languages - eventually, what we could
;; provide in the COINVENT project is a set of sample implementations in various
;; languages, together with an API for reporting/logging progress.  In order to
;; make this attractive to potential users (and generate some empirical data) we
;; might want to have a computational creativity contest.
;;
;; From a philosophical point of view, note that simply creating more and more
;; concepts probably isn't the most "creative" -- actually, defining (and passing)
;; new tests which get at different facets of creativity would tend to improve the
;; overall "score".  Maybe each new test should be treated as a "multiplier" or
;; something.
;;
;; From a procedural point of view, the system should, accordingly, work on
;; several levels:
;;
;; - A test that can detect when e.g. a new framing has been produced by
;; looking for new documentation strings or whatever else qualifies as a "framing".
;;
;; - A test that can detect when a new *test* has been written, E.g. in addition
;; to documentation strings, suppose we define a new kind of framing object called
;; a "walkthrough", and we will consider a new framing to have been produced
;; whenever either a new doc string or a new walkthrough is produced.  In the
;; first place, we need to note the existence of the walkthrough test.
;;
;; "Tests" themselves could be considered to be concepts or perhaps aesthetics
;; (typically they map into {0,1}, but in general they could map to a set of error
;; codes).
;;
;; Note also that the tests generally need to be applied to the "increment", for
;; instance, all *new* code that has been written since the last commit.  So, we
;; need a method for extracting this increment.  I did something similar in my
;; thesis that analysed git logs and looked for named entities in the diffs.
;; Extracting a meaningful piece of code *directly* from a line-diff is not
;; always going to be possible, since adding a single line typically isn't a
;; "semantically" meaningful change.
;;
;; Let's assume that we can get ahold of the semantically meaningful changes with
;; a little bit of code that scans a git commit and then reads the corresponding
;; file.  Then we need to analyse this new code with the available tests -- and
;; maybe, for user-friendly record-keeping, update the commit message
;; automatically with a tally.  All of this git stuff is a fairly specific
;; implementation detail.
;;
;; We could start with something simpler, like identifying the number of `defun'
;; and `defvar' usages in a given file.  It's not entirely clear that the
;; `ert-deftest' mechanism will be the best way to go, rather than using some
;; other ad hoc code scanning and reporting mechanism, but we can try!
;;
;;  [After a first pass, I can see that ERT does work, but the reporting mechanism
;;  isn't quite aligned with what we want to do, so after a prototyping phase, it
;;  would be nice to augment ERT with some more "qualitative" reporting
;;  mechanisms.]
;;
;; The ERT documentation says "ERT only provides explanations for predicates that
;; have an explanation function registered."  But for now, explanations are only
;; triggered when a test fails, so the intuitive logic in the prototype is
;; "reversed", i.e. "failing" is good, because it produces explanations.
;;
;; They also say:
;;
;;    ERT does not have built-in support for mocks or stubs.  The package
;; `el-mock' (see `http://www.emacswiki.org/emacs/el-mock.el') offers
;; mocks for Emacs Lisp and can be used in conjunction with ERT.
;;
;; Potentially worth checking this out when we get to the point of implementing a
;; proper type theoretic schema.
;;; Documentation: Implementation plan:
;; The code in the ert-x package includes a macro for running tests on the current
;; buffer, called `ert-with-buffer-renamed'.  In theory, we could use this to test
;; how many matches for a given regexp are present in the buffer, say.  The one
;; issue here is figuring out how to get ERT to report something qualitative,
;; other than just pass/fail.
;;
;; We have a sort of cheap method of doing that now, in the section "Implement a
;; cheap counting test".
;;
;; We can have the code take in an "increment" to scan, see "Pass in an increment"
;;
;; We can run all of the tests on a selected increment, see "Run a battery of
;; tests on a given file".
;;
;; Next up, we would want to do a bit of "model selection", i.e. check which of
;; the 8 possible tests are actually implemented, and run only those.  Although
;; actually there are 8 *types* of test, and not just 8 tests.  Maybe if I take
;; out the "shoulds" the tests will automatically pass?  Yes, that's true.  So,
;; this way I will only see reporting on the tests that are actually implemented.
;;
;; It seems like I might as well just go ahead and implement this in ONE case
;; (e.g. the APMXI case) and then I can take another pass to implement it in a
;; more general type theoretic way.
;;
;; [...]
;;
;; Develop a nicer reporting framework so that we're not just seeing a bunch of
;; failed tests, but instead, a nice-looking summary.  Note that this is not
;; separate from the type theoretic issues - we want to have a "score card"
;; for each increment.
;;; Code:
(require 'ert)
(require 'ert-x)
;;; Schema for main kinds of tests that we're interested in
;;; Basic versions
;; These tests should take an "increment" as an argument.  We'll have to come up
;; with a way to pass in a buffer or string to the test, perhaps using a fixture
;; (see below).
(ert-deftest FACE-new-framing-produced ()
  "Test whether a new framing exists now (for some definition of \"framing\").
Hint: This would look for the existence of new documentation, for instance."
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-aesthetic-produced ()
  "Test whether a new aesthetic exists now (for some definition of \"aesthetic\").
Hint: \"Sophisticated\" (but elementary) definition: A new map into [0,1] exists.
Example: this concept is interesting, but it needs:
- an example
- a picture
- a relationship to another concept in the domain
- a conjecture
etc."
  ;; jac - Note that even more complex version would allow a map to another manifold.
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-concept-produced ()
  "Test whether a new concept exists now (for some definition of \"concept\").
Hint: Naive version:  I have a database of facts and I've added something to it
Sophisticated version:  I have a collection of input/output functions and
I've added something to it"
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-example-produced ()
  "Test whether a new example exists now (for some definition of \"example\").
Hint: Example or instantiation of a concept.  (Every example is
also an \"expression\" of a concept.)
Concept : prime factorization (best case, this is embodied
in a program for doing prime factorization)
Example: 14 -> 7*2
Some examples of examples:  
- a mathematics problem or exercise (the problem \"begs\" the example)
- an application"
  ;(should (= (+ 1 2) 4))
  )
;;; `method' versions: at least on the surface, this is harder
(ert-deftest FACE-new-framing-method-produced ()
  "Test whether a new method for framing exists now (for some definition of \"framing\").
Hint: This might look for the existence of new technique for generating documentation,
for instance."
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-aesthetic-method-produced ()
  "Test whether a new method for making an aesthetic exists now (for some definition of \"aesthetic\").
Hint: all this is, is a new way of computing a fitness function!"
  ;; jac Nov 7, 2013 - Maybe there's something about survival analysis that could added in here.
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-concept-method-produced ()
  "Test whether a new method for making a concept exists now (for some definition of \"concept\").
Hint: Naive version:  I have a new routine for adding things to my database (e.g.
Mike's system can look something up online). Sophisticated version:  I have a new
macro that writes functions."
  ;(should (= (+ 1 2) 4))
  )
(ert-deftest FACE-new-example-method-produced ()
  "Test whether a new method for making an example exists now (for some definition of \"example\").
Hint: Euler's summation to pi^2 / 6 is a proof, but also an illustration
of a method for doing other proofs."
  ;(should (= (+ 1 2) 4))
  )
;;; Implement a cheap counting test:
;; The test "fails", but produces the actual number of "ert-deftests" as part of
;; the explanation, which is what I was going for.  I can define similar counting
;; tests for the number of defuns and number of defvars
(ert-deftest FACE-count-tests ()
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment))
                  (let ((number-of-tests (count-matches "^(ert-deftest" (point-min) (point-max))))
                    (should (equal number-of-tests 0)))))
(ert-deftest FACE-count-defuns ()
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment))
                  (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-max))))
                    (should (equal number-of-defuns 0)))))
(ert-deftest FACE-count-defvars ()
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment))
                  (let ((number-of-variables (count-matches "^(defvar" (point-min) (point-max))))
                    (should (equal number-of-variables 0)))))
;;; Pass in an increment:
;; This is trickier, because the increment has to be sent as an argument.  I guess
;; I can create a fixture that allows the user to interactively supply the name of
;; a buffer to test, for example.
;;
;; OK, this code all works, but I'm commenting out for now b/c the interaction would be annoying when I'm testing
;(defun FACE-select-buffer-to-count-fixture (body)
;  (let ((buffer (read-buffer "Buffer to scan: ")))
;    (unwind-protect (progn 
;                     (save-excursion (set-buffer (get-buffer buffer))
;                                      (funcall body)))
;      )))
;; A test that makes use of the fixture described above
;(ert-deftest FACE-select-buffer-and-count-test ()
;  (FACE-select-buffer-to-count-fixture
;   (lambda ()
;     (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-max))))
;      (should (equal number-of-defuns 0))))))
;;; Run a battery of tests on a given file:
;; All I really need is a function similar to `ert-run-tests-interactively', but
;; that takes an argument, and makes that available to the various tests before
;; the function runs.  That's easy.  Later we'll want a version that knows where
;; to look for the increment, and just produces a report.
(defvar FACE-buffer-as-increment nil)
(defun FACE-select-buffer-and-run-tests (buffer)
  (interactive "b")
  (setq FACE-buffer-as-increment buffer)
  (ert-run-tests-interactively "^FACE"))
;;; End of file

modified files:
 test-driven-development.el

[master 3f0dfec] Add the test-driven-development.el file
 1 files changed, 293 insertions(+), 0 deletions(-)
 create mode 100644 test-driven-development.el
~/test-driven-development $ ls
#post-commit#  README  README~  post-commit  post-commit~  test-driven-development.el
~/test-driven-development $ rm *~
~/test-driven-development $ ls
#post-commit#  README  post-commit  test-driven-development.el
~/test-driven-development $ rm #post-commit\# 
rm: missing operand
Try `rm --help' for more information.
~/test-driven-development $ rm \#post-commit\# 
~/test-driven-development $ ls
README  post-commit  test-driven-development.el
~/test-driven-development $ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.#post-commit
nothing added to commit but untracked files present (use "git add" to track)
~/test-driven-development $ rm .#post-commit
~/test-driven-development $ ls
README  post-commit  test-driven-development.el
~/test-driven-development $ git status
# On branch master
nothing to commit (working directory clean)
~/test-driven-development $ git commit -a -m "Add a little bit of documentation"
sha1: b946495e55c062e59af0fd162e2dd8e94b76ec0e
added lines:
 ;;; Documentation:
;; This file demonstrates some simple post commit tricks
;; with Emacs.  It can print out simple changed lines in a
;; buffer.  We could feed these lines into the
;; test-driven-development.el file, or use this data from
;; inside that file to get a more interesting idea of the
;; "increment" to analyse.
;;
;; We might want to get the magit package into the loop to
;; more seamlessly commit things without leaving Emacs, or
;; without getting away from the usual development
;; workflow in Emacs.
;;
;; The main problem at the moment is that
;; test-driven-development.el uses ert in an interactive
;; manner.  We could also load all of the functions there
;; and run ert in a non-interactive manner, resulting in
;; more detailed output from this script.
;; That might be the easiest thing to do.  Note that we
;; ought to be able to doctor the commit message with
;; another command.
;;; Notes:
;; This is the old way to call emacs scripts
;;; Function definitions:

 (defun get-added-lines-per-commit (sha1)
;;; Body:

 (let* ((orig-commit-message (shell-command-to-string "git log -1"))
;; The idea in this file is to use some variant of test
;; driven development (for now, within the framework
;; describe in ~/emacs-24.3/info/ert.info) as a way to
;; keep track of an evolving model of a codebase.  It is
;; build around a set of tests that instantiate the FACE
;; model of computational creativity.  This model is
;; specified, at the outline level, as follows:
;; - In a given instantiation of this programme, we might
;; model something like the growth of the APM XI corpus
;; through the addition of new examples and new
;; - In general, like with other kinds of test-driven
;; development, we might write the tests "first" and use
;; these to specify objectives as a "development roadmap"
;; i.e. when those tests are passing, a given phase of the
;; project is complete.
;; Note that it seems vastly easier to build a particular
;; instantiation of the FACE model than it is to build a
;; general-purpose test that would always say "you have
;; added a new concept" or "you have added a new
;; aesthetic-method".
;; Instead of having a fully general model that works
;; every time, we could instead come up with a
;; type-theoretic treatment of the FACE schema, so that we
;; could check whether a given system implements a test
;; for a given facet of FACE.
;; If we go that route, it might make more sense to
;; implement the test system in Haskell rather than
;; LISP... but of course we actually want to be flexible,
;; so we need to maintain a general sense of a test
;; "implementing" a given type of test, across different
;; programming languages - eventually, what we could
;; provide in the COINVENT project is a set of sample
;; implementations in various languages, together with an
;; API for reporting/logging progress.  In order to make
;; this attractive to potential users (and generate some
;; empirical data) we might want to have a computational
;; creativity contest.
;; From a philosophical point of view, note that simply
;; creating more and more concepts probably isn't the most
;; "creative" -- actually, defining (and passing) new
;; tests which get at different facets of creativity would
;; tend to improve the overall "score".  Maybe each new
;; test should be treated as a "multiplier" or something.
;; From a procedural point of view, the system should,
;; accordingly, work on several levels:
;; - A test that can detect when e.g. a new framing has
;; been produced by looking for new documentation strings
;; or whatever else qualifies as a "framing".
;; - A test that can detect when a new *test* has been
;; written, E.g. in addition to documentation strings,
;; suppose we define a new kind of framing object called a
;; "walkthrough", and we will consider a new framing to
;; have been produced whenever either a new doc string or
;; a new walkthrough is produced.  In the first place, we
;; need to note the existence of the walkthrough test.
;; "Tests" themselves could be considered to be concepts
;; or perhaps aesthetics (typically they map into {0,1},
;; but in general they could map to a set of error codes).
;; Note also that the tests generally need to be applied
;; to the "increment", for instance, all *new* code that
;; has been written since the last commit.  So, we need a
;; method for extracting this increment.  I did something
;; similar in my thesis that analysed git logs and looked
;; for named entities in the diffs.  Extracting a
;; meaningful piece of code *directly* from a line-diff is
;; not always going to be possible, since adding a single
;; line typically isn't a "semantically" meaningful
;; change.
;; Let's assume that we can get ahold of the semantically
;; meaningful changes with a little bit of code that scans
;; a git commit and then reads the corresponding file.
;; Then we need to analyse this new code with the
;; available tests -- and maybe, for user-friendly
;; record-keeping, update the commit message automatically
;; with a tally.  All of this git stuff is a fairly
;; specific implementation detail.
;; We could start with something simpler, like identifying
;; the number of `defun' and `defvar' usages in a given
;; file.  It's not entirely clear that the `ert-deftest'
;; mechanism will be the best way to go, rather than using
;; some other ad hoc code scanning and reporting
;; mechanism, but we can try!
;;  [After a first pass, I can see that ERT does work, but
;;  the reporting mechanism isn't quite aligned with what
;;  we want to do, so after a prototyping phase, it would
;;  be nice to augment ERT with some more "qualitative"
;;  reporting mechanisms.]
;; The ERT documentation says "ERT only provides
;; explanations for predicates that have an explanation
;; function registered."  But for now, explanations are
;; only triggered when a test fails, so the intuitive
;; logic in the prototype is "reversed", i.e. "failing" is
;; good, because it produces explanations.
;;    ERT does not have built-in support for mocks or
;; stubs.  The package `el-mock' (see
;; `http://www.emacswiki.org/emacs/el-mock.el') offers
;; mocks for Emacs Lisp and can be used in conjunction
;; with ERT.
;; Potentially worth checking this out when we get to the
;; point of implementing a proper type theoretic schema.
;; The code in the ert-x package includes a macro for
;; running tests on the current buffer, called
;; `ert-with-buffer-renamed'.  In theory, we could use
;; this to test how many matches for a given regexp are
;; present in the buffer, say.  The one issue here is
;; figuring out how to get ERT to report something
;; qualitative, other than just pass/fail.
;; We have a sort of cheap method of doing that now, in
;; the section "Implement a cheap counting test".
;; We can have the code take in an "increment" to scan,
;; see "Pass in an increment"
;; We can run all of the tests on a selected increment,
;; see "Run a battery of tests on a given file".
;; Next up, we would want to do a bit of "model
;; selection", i.e. check which of the 8 possible tests
;; are actually implemented, and run only those.  Although
;; actually there are 8 *types* of test, and not just 8
;; tests.  Maybe if I take out the "shoulds" the tests
;; will automatically pass?  Yes, that's true.  So, this
;; way I will only see reporting on the tests that are
;; actually implemented.
;; It seems like I might as well just go ahead and
;; implement this in ONE case (e.g. the APMXI case) and
;; then I can take another pass to implement it in a more
;; general type theoretic way.
;; Develop a nicer reporting framework so that we're not
;; just seeing a bunch of failed tests, but instead, a
;; nice-looking summary.  Note that this is not separate
;; from the type theoretic issues - we want to have a
;; "score card" for each increment.
;; These tests should take an "increment" as an argument.
;; We'll have to come up with a way to pass in a buffer or
;; string to the test, perhaps using a fixture (see
;; below).

   ;; jac - Note that even more complex version would allow a map to another manifold.
;; The test "fails", but produces the actual number of
;; "ert-deftests" as part of the explanation, which is
;; what I was going for.  I can define similar counting
;; This is trickier, because the increment has to be sent
;; as an argument.  I guess I can create a fixture that
;; allows the user to interactively supply the name of a
;; buffer to test, for example.
;; OK, this code all works, but I'm commenting out for now
;; b/c the interaction would be annoying when I'm testing
;; All I really need is a function similar to
;; `ert-run-tests-interactively', but that takes an
;; argument, and makes that available to the various tests
;; before the function runs.  That's easy.  Later we'll
;; want a version that knows where to look for the
;; increment, and just produces a report.

modified files:
 post-commit
test-driven-development.el

[master b946495] Add a little bit of documentation
 2 files changed, 181 insertions(+), 108 deletions(-)
~/test-driven-development $ git commit -a -m "Fix printing so it doesn't include spaces"
sha1: 94ef2d4f78c206ba73ecdf72678542cf4a4de105
added lines:
  (princ (format "added lines:\n%s\n"  (get-added-lines-per-commit sha1)))
  (princ (format "modified files:\n%s\n"  (get-modified-files-per-commit sha1))))

modified files:
post-commit

[master 94ef2d4] Fix printing so it doesn't include spaces
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git log
WARNING: terminal is not fully functional
-  (press RETURN) 
commit 94ef2d4f78c206ba73ecdf72678542cf4a4de105
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:32:14 2013 +0000

    Fix printing so it doesn't include spaces

commit b946495e55c062e59af0fd162e2dd8e94b76ec0e
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:31:41 2013 +0000

    Add a little bit of documentation

commit 3f0dfec2af8dac3f915809decb7c587c21ae3ff2
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:22:46 2013 +0000

    Add the test-driven-development.el file

commit e79f4de517a906d45f5e28872b315378f90d3179
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:18:22 2013 +0000

    Just the filename

: 
commit 7130a10baa52baafff648d81e01bc9910f7ec3ac
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:17:54 2013 +0000

    fix regexp some more, I think I have it now

commit a11d96c38776a4e3115e08026196d4f2e4ec8c37
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:17:35 2013 +0000

    fix regexp some more

commit f42ec16766cf396fe6680693375899d0d742f23a
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:14:47 2013 +0000

    fix regexp some more

commit b1d4109f66cd91c7268585d878a4173e0765d7b8
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:14:12 2013 +0000

    fix regexp

: 
commit b5e65bb1401ea87c6304e7be3bd600b2f126eedc
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:13:07 2013 +0000

    Also print names of modified files

commit 25211e250deff8d8debf6e5a54d560391556eda1
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:10:40 2013 +0000

    Don't return the name of the changed file

commit dc91e37b376d8754a607bd4ee53f739e6768aa4b
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:09:48 2013 +0000

    Change name of function

commit e9f7d984f94b46209bf6651ad821101bff98c32b
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:09:13 2013 +0000

    return string

: 
commit b115cce5b28598fa798fa861a2739ed138b1faae
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:08:04 2013 +0000

    Fix temp buffer

commit 5329459aa4deb2e2b95809b211c7e4cddb0f4cc2
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:07:34 2013 +0000

    Try to show added lines

commit 0fd1236fd0b4fd0920ca06593b674a53f62b5798
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:06:54 2013 +0000

    Try to show added lines

commit 741d32ca745d05cc1ede7cd1fcfa14594bcb7599
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:04:28 2013 +0000

    fix typo

: 
commit 8824e381f7a6cd3c39de1ecc190c7b8a41bd890d
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:03:49 2013 +0000

    different access method

commit 203226daf9c6adc8902d1b8d512e869fdf6fcef8
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:02:56 2013 +0000

    Getting a sha1 for real and printing it

commit 96adf303c5add7f51e2483657fe0728f0a3c258f
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:02:45 2013 +0000

    Getting a sha1 for real

commit 6ed446916720fee0e5a247bd132d682ac0fc3b44
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 22:02:27 2013 +0000

    Getting a sha1

: 
commit cfbf286709f503e5788bc8d60fc36237473073da
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:56:36 2013 +0000

    OK, things are working now

commit 12f6e28a0d9bcd6ada23490686431ede82989b2a
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:55:26 2013 +0000

    Update code

commit 2bbe541ed8da693185cae925fd1fcc6f3c7c4a29
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:54:51 2013 +0000

    Update README

commit 4d2b129304ba83e3bbc152ec5fa822ebda4c3d24
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:54:25 2013 +0000

    Add sample hook content

: 
commit 23e058ebdd8611281c7a2d01eefe71b85cb4fddf
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:49:34 2013 +0000

    Update README

commit c44435f7db3a87730fada18e908793a8134eb0fb
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:48:13 2013 +0000

    Update README

commit 4eb2be362e68e66500ab9151aaa6906967b5d26a
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:46:43 2013 +0000

    Update README

commit 7f79bedf385fb69b78920b71eb2f5ed56436d35f
Author: Joe Corneli <holtzermann17@gmail.com>
Date:   Wed Nov 13 21:43:29 2013 +0000

    Adding README
(END)  
(END) q
~/test-driven-development $ ~/test-driven-development $ git commit -a -m "Try to integrate an ert batch mode call"
Cannot open load file: ./test-driven-development.el
[master b97e15d] Try to integrate an ert batch mode call
 1 files changed, 16 insertions(+), 4 deletions(-)
~/test-driven-development $ ls
README  post-commit  post-commit-orig  test-driven-development.el  test-driven-development.el~
~/test-driven-development $ pwd
/Users/jac2349/test-driven-development
~/test-driven-development $ git commit -a -m "Change path"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: fbaad54b895a7b236456e96f9afdb2f2d7e5b4e4
added lines:
(load "/Users/jac2349/test-driven-development/test-driven-development.el")

modified files:
post-commit


Running 11 tests (2013-11-14 09:51:47+0000)
Test FACE-count-defuns backtrace:
  signal(ert-test-failed (((should (equal number-of-defuns 0)) :form (
  ert-fail(((should (equal number-of-defuns 0)) :form (equal 2 0) :val
  (if (unwind-protect (setq value-7 (apply fn-5 args-6)) (setq form-de
  (let (form-description-9) (if (unwind-protect (setq value-7 (apply f
  (let ((value-7 (quote ert-form-evaluation-aborted-8))) (let (form-de
  (let ((fn-5 (function equal)) (args-6 (list number-of-defuns 0))) (l
  (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment)) (
  (lambda nil (save-excursion (set-buffer (get-buffer FACE-buffer-as-i
  byte-code("\306\307!q\210\310\216\311 \312\216\313\314\315\316\3
  ert--run-test-internal([cl-struct-ert--test-execution-info [cl-struc
  byte-code("\306\307!\211\211r\310\311!q\210\312 d\313\223)L\210)\3
  ert-run-test([cl-struct-ert-test FACE-count-defuns nil (lambda nil (
  ert-run-or-rerun-test([cl-struct-ert--stats "^FACE" [[cl-struct-ert-
  ert-run-tests("^FACE" #[(event-type &rest event-args) "\30\307\"\2
  ert-run-tests-batch("^FACE")
  ert-run-tests-batch-and-exit("^FACE")
  (let* ((orig-commit-message (shell-command-to-string "git log -1")) 
  eval-buffer(#<buffer  *load*> nil "/Users/jac2349/test-driven-develo
  load-with-code-conversion("/Users/jac2349/test-driven-development/.g
  load("/Users/jac2349/test-driven-development/.git/hooks/post-commit"
  command-line-1(("-scriptload" ".git/hooks/post-commit"))
  command-line()
  normal-top-level()
Test FACE-count-defuns condition:
    (ert-test-failed
     ((should
       (equal number-of-defuns 0))
      :form
      (equal 2 0)
      :value nil :explanation
      (different-atoms
       (2 "#x2" "?")
       (0 "#x0" "? "))))
   FAILED   1/11  FACE-count-defuns
   passed   2/11  FACE-count-defvars
   passed   3/11  FACE-count-tests
   passed   4/11  FACE-new-aesthetic-method-produced
   passed   5/11  FACE-new-aesthetic-produced
   passed   6/11  FACE-new-concept-method-produced
   passed   7/11  FACE-new-concept-produced
   passed   8/11  FACE-new-example-method-produced
   passed   9/11  FACE-new-example-produced
   passed  10/11  FACE-new-framing-method-produced
   passed  11/11  FACE-new-framing-produced

Ran 11 tests, 10 results as expected, 1 unexpected (2013-11-14 09:51:48+0000)

1 unexpected results:
   FAILED  FACE-count-defuns

[master fbaad54] Change path
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Write out the text we are scanning just to have a look"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: 61b3eeed81f67e8ea720103e341eba672a8b5e14
added lines:
  (write-file "/Users/jac2349/test-driven-development/have-a-look")

modified files:
post-commit


Saving file /Users/jac2349/test-driven-development/have-a-look...
Loading vc-git...
Wrote /Users/jac2349/test-driven-development/have-a-look
Running 11 tests (2013-11-14 09:54:31+0000)
Test FACE-count-defuns backtrace:
  signal(ert-test-failed (((should (equal number-of-defuns 0)) :form (
  ert-fail(((should (equal number-of-defuns 0)) :form (equal 2 0) :val
  (if (unwind-protect (setq value-7 (apply fn-5 args-6)) (setq form-de
  (let (form-description-9) (if (unwind-protect (setq value-7 (apply f
  (let ((value-7 (quote ert-form-evaluation-aborted-8))) (let (form-de
  (let ((fn-5 (function equal)) (args-6 (list number-of-defuns 0))) (l
  (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment)) (
  (lambda nil (save-excursion (set-buffer (get-buffer FACE-buffer-as-i
  byte-code("\306\307!q\210\310\216\311 \312\216\313\314\315\316\3
  ert--run-test-internal([cl-struct-ert--test-execution-info [cl-struc
  byte-code("\306\307!\211\211r\310\311!q\210\312 d\313\223)L\210)\3
  ert-run-test([cl-struct-ert-test FACE-count-defuns nil (lambda nil (
  ert-run-or-rerun-test([cl-struct-ert--stats "^FACE" [[cl-struct-ert-
  ert-run-tests("^FACE" #[(event-type &rest event-args) "\30\307\"\2
  ert-run-tests-batch("^FACE")
  ert-run-tests-batch-and-exit("^FACE")
  (let* ((orig-commit-message (shell-command-to-string "git log -1")) 
  eval-buffer(#<buffer  *load*> nil "/Users/jac2349/test-driven-develo
  load-with-code-conversion("/Users/jac2349/test-driven-development/.g
  load("/Users/jac2349/test-driven-development/.git/hooks/post-commit"
  command-line-1(("-scriptload" ".git/hooks/post-commit"))
  command-line()
  normal-top-level()
Test FACE-count-defuns condition:
    (ert-test-failed
     ((should
       (equal number-of-defuns 0))
      :form
      (equal 2 0)
      :value nil :explanation
      (different-atoms
       (2 "#x2" "?")
       (0 "#x0" "? "))))
   FAILED   1/11  FACE-count-defuns
   passed   2/11  FACE-count-defvars
   passed   3/11  FACE-count-tests
   passed   4/11  FACE-new-aesthetic-method-produced
   passed   5/11  FACE-new-aesthetic-produced
   passed   6/11  FACE-new-concept-method-produced
   passed   7/11  FACE-new-concept-produced
   passed   8/11  FACE-new-example-method-produced
   passed   9/11  FACE-new-example-produced
   passed  10/11  FACE-new-framing-method-produced
   passed  11/11  FACE-new-framing-produced

Ran 11 tests, 10 results as expected, 1 unexpected (2013-11-14 09:54:31+0000)

1 unexpected results:
   FAILED  FACE-count-defuns

[master 61b3eee] Write out the text we are scanning just to have a look
 1 files changed, 1 insertions(+), 0 deletions(-)
~/test-driven-development $ git commit -a -m "Curious about that 2 let's try with 3"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: dd8b80df8b5c3c56d1d2d2161511a6d1a6c6b2ff
added lines:
(defun example ()
  (princ (format "%d\n" (+ 1 2))))

modified files:
post-commit


Saving file /Users/jac2349/test-driven-development/have-a-look...
Loading vc-git...
Wrote /Users/jac2349/test-driven-development/have-a-look
Running 11 tests (2013-11-14 09:56:51+0000)
Test FACE-count-defuns backtrace:
  signal(ert-test-failed (((should (equal number-of-defuns 0)) :form (
  ert-fail(((should (equal number-of-defuns 0)) :form (equal 3 0) :val
  (if (unwind-protect (setq value-7 (apply fn-5 args-6)) (setq form-de
  (let (form-description-9) (if (unwind-protect (setq value-7 (apply f
  (let ((value-7 (quote ert-form-evaluation-aborted-8))) (let (form-de
  (let ((fn-5 (function equal)) (args-6 (list number-of-defuns 0))) (l
  (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment)) (
  (lambda nil (save-excursion (set-buffer (get-buffer FACE-buffer-as-i
  byte-code("\306\307!q\210\310\216\311 \312\216\313\314\315\316\3
  ert--run-test-internal([cl-struct-ert--test-execution-info [cl-struc
  byte-code("\306\307!\211\211r\310\311!q\210\312 d\313\223)L\210)\3
  ert-run-test([cl-struct-ert-test FACE-count-defuns nil (lambda nil (
  ert-run-or-rerun-test([cl-struct-ert--stats "^FACE" [[cl-struct-ert-
  ert-run-tests("^FACE" #[(event-type &rest event-args) "\30\307\"\2
  ert-run-tests-batch("^FACE")
  ert-run-tests-batch-and-exit("^FACE")
  (let* ((orig-commit-message (shell-command-to-string "git log -1")) 
  eval-buffer(#<buffer  *load*> nil "/Users/jac2349/test-driven-develo
  load-with-code-conversion("/Users/jac2349/test-driven-development/.g
  load("/Users/jac2349/test-driven-development/.git/hooks/post-commit"
  command-line-1(("-scriptload" ".git/hooks/post-commit"))
  command-line()
  normal-top-level()
Test FACE-count-defuns condition:
    (ert-test-failed
     ((should
       (equal number-of-defuns 0))
      :form
      (equal 3 0)
      :value nil :explanation
      (different-atoms
       (3 "#x3" "?")
       (0 "#x0" "? "))))
   FAILED   1/11  FACE-count-defuns
   passed   2/11  FACE-count-defvars
   passed   3/11  FACE-count-tests
   passed   4/11  FACE-new-aesthetic-method-produced
   passed   5/11  FACE-new-aesthetic-produced
   passed   6/11  FACE-new-concept-method-produced
   passed   7/11  FACE-new-concept-produced
   passed   8/11  FACE-new-example-method-produced
   passed   9/11  FACE-new-example-produced
   passed  10/11  FACE-new-framing-method-produced
   passed  11/11  FACE-new-framing-produced

Ran 11 tests, 10 results as expected, 1 unexpected (2013-11-14 09:56:52+0000)

1 unexpected results:
   FAILED  FACE-count-defuns

[master dd8b80d] Curious about that 2 let's try with 3
 1 files changed, 2 insertions(+), 2 deletions(-)
~/test-driven-development $ git commit -a -m "Ok, now we can look at the right buffer"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: f13a7ad96eb212ed058829f370be3ff8943d5b78
added lines:
;(defun example ()
;  (princ (format "%d\n" (+ 1 2))))
  (setq FACE-buffer-as-increment working-buffer)

modified files:
post-commit


Saving file /Users/jac2349/test-driven-development/have-a-look...
Loading vc-git...
Wrote /Users/jac2349/test-driven-development/have-a-look
Running 11 tests (2013-11-14 09:57:19+0000)
   passed   1/11  FACE-count-defuns
   passed   2/11  FACE-count-defvars
   passed   3/11  FACE-count-tests
   passed   4/11  FACE-new-aesthetic-method-produced
   passed   5/11  FACE-new-aesthetic-produced
   passed   6/11  FACE-new-concept-method-produced
   passed   7/11  FACE-new-concept-produced
   passed   8/11  FACE-new-example-method-produced
   passed   9/11  FACE-new-example-produced
   passed  10/11  FACE-new-framing-method-produced
   passed  11/11  FACE-new-framing-produced

Ran 11 tests, 11 results as expected (2013-11-14 09:57:19+0000)

[master f13a7ad] Ok, now we can look at the right buffer
 1 files changed, 3 insertions(+), 3 deletions(-)
~/test-driven-development $ git commit -a -m "Commenting out the test buffer"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: 049976d6126cd529816027ae6a88a1febd7a9a03
added lines:
  ;(write-file "/Users/jac2349/test-driven-development/have-a-look")

modified files:
post-commit


Running 11 tests (2013-11-14 09:58:12+0000)
   passed   1/11  FACE-count-defuns
   passed   2/11  FACE-count-defvars
   passed   3/11  FACE-count-tests
   passed   4/11  FACE-new-aesthetic-method-produced
   passed   5/11  FACE-new-aesthetic-produced
   passed   6/11  FACE-new-concept-method-produced
   passed   7/11  FACE-new-concept-produced
   passed   8/11  FACE-new-example-method-produced
   passed   9/11  FACE-new-example-produced
   passed  10/11  FACE-new-framing-method-produced
   passed  11/11  FACE-new-framing-produced

Ran 11 tests, 11 results as expected (2013-11-14 09:58:12+0000)

[master 049976d] Commenting out the test buffer
 1 files changed, 1 insertions(+), 1 deletions(-)
~/test-driven-development $ git commit -a -m "Lots more discussion and a couple more tests"
Loading /Users/jac2349/test-driven-development/test-driven-development.el (source)...
sha1: ea5daeaab19dc2463af27ad8970cef3e019c1ba8
added lines:
;;  [Making our diffs more semantic is an obvious thing to
;;  fix.]
;;
;;; Documentation: Comments on first working prototype:
;; I now have a prototype that can run tests
;; non-interactively on the incremental changes in a git
;; repository, using the git post-commit hook.  As I
;; mentioned just above, it would be nice to have a
;; somewhat better reporting mechanism, and to then alter
;; the commit messages by sticking relevant "score card"
;; information into them.  This is eminently doable.
;;
;; For now the "interesting things we can notice" are
;; defined in a rather simplistic way, since we only
;; notice a few regexps that describe the creation of
;; defuns and similar.  However, this is already a usable
;; start, i.e. I can easily make some tests that notice
;; things of interest in hcode (e.g. defthm instead of
;; deftest; I'll have to take a look at my old notes to
;; see what's there).
;;
;; The thing I'm thinking is: actually, just creating more
;; and more definitions -- at least in this manner -- is
;; not particularly creative.  On one level it might be
;; "more creative" to do a lot of them (as with a big
;; translation effort) and ultimately when very many
;; definitions are known, it would be creative to add
;; something truly new.  However, one might expect a very
;; long non-creative interlude in the middle, where we
;; just transcribe things from lots and lots of known
;; sources.  Clearly there would be *some* elements of
;; creativity in this process, however: having to do in
;; this case with inventive forms of transcription or
;; translation, with interesting speed-ups and so forth.
;;
;; But the basic point is that creativity is only really
;; defined relative to an "edge".  Once we've done that
;; thing before, or a lot of things like it, then another
;; iteration of the same is not particularly creative.
;;
;; Continuing this idea, do we want to count "new"
;; appearances of `defn' or `defthm' as truly new
;; concepts, if they have simply been transcribed from
;; somewhere else?  (If so, we'll have to do a little more
;; integration work to describe how one test triggers
;; recognition for another test.)

 ;;; Code:
  (save-excursion 
    (set-buffer (get-buffer FACE-buffer-as-increment))
    (let ((number-of-tests (count-matches "^(ert-deftest" (point-min) (point-max))))
      (should (equal number-of-tests 0)))))
  (save-excursion
    (set-buffer (get-buffer FACE-buffer-as-increment))
    (let ((number-of-defuns (count-matches "^(defun" (point-min) (point-max))))
      (should (equal number-of-defuns 0)))))
  (save-excursion
    (set-buffer (get-buffer FACE-buffer-as-increment))
    (let ((number-of-variables (count-matches "^(defvar" (point-min) (point-max))))
      (should (equal number-of-variables 0)))))
(ert-deftest FACE-count-defns ()
  (save-excursion
    (set-buffer (get-buffer FACE-buffer-as-increment))
    (let ((number-of-variables (count-matches "^(defn" (point-min) (point-max))))
      (should (equal number-of-variables 0)))))
(ert-deftest FACE-count-defthm ()
  (save-excursion
    (set-buffer (get-buffer FACE-buffer-as-increment))
    (let ((number-of-variables (count-matches "^(defn" (point-min) (point-max))))
      (should (equal number-of-variables 0)))))

modified files:
test-driven-development.el


Running 13 tests (2013-11-14 10:17:17+0000)
   passed   1/13  FACE-count-defns
   passed   2/13  FACE-count-defthm
   passed   3/13  FACE-count-defuns
   passed   4/13  FACE-count-defvars
Test FACE-count-tests backtrace:
  signal(ert-test-failed (((should (equal number-of-tests 0)) :form (e
  ert-fail(((should (equal number-of-tests 0)) :form (equal 2 0) :valu
  (if (unwind-protect (setq value-2 (apply fn-0 args-1)) (setq form-de
  (let (form-description-4) (if (unwind-protect (setq value-2 (apply f
  (let ((value-2 (quote ert-form-evaluation-aborted-3))) (let (form-de
  (let ((fn-0 (function equal)) (args-1 (list number-of-tests 0))) (le
  (let ((number-of-tests (count-matches "^(ert-deftest" (point-min) (p
  (save-excursion (set-buffer (get-buffer FACE-buffer-as-increment)) (
  (lambda nil (save-excursion (set-buffer (get-buffer FACE-buffer-as-i
  byte-code("\306\307!q\210\310\216\311 \312\216\313\314\315\316\3
  ert--run-test-internal([cl-struct-ert--test-execution-info [cl-struc
  byte-code("\306\307!\211\211r\310\311!q\210\312 d\313\223)L\210)\3
  ert-run-test([cl-struct-ert-test FACE-count-tests nil (lambda nil (s
  ert-run-or-rerun-test([cl-struct-ert--stats "^FACE" [[cl-struct-ert-
  ert-run-tests("^FACE" #[(event-type &rest event-args) "\30\307\"\2
  ert-run-tests-batch("^FACE")
  ert-run-tests-batch-and-exit("^FACE")
  (let* ((orig-commit-message (shell-command-to-string "git log -1")) 
  eval-buffer(#<buffer  *load*> nil "/Users/jac2349/test-driven-develo
  load-with-code-conversion("/Users/jac2349/test-driven-development/.g
  load("/Users/jac2349/test-driven-development/.git/hooks/post-commit"
  command-line-1(("-scriptload" ".git/hooks/post-commit"))
  command-line()
  normal-top-level()
Test FACE-count-tests condition:
    (ert-test-failed
     ((should
       (equal number-of-tests 0))
      :form
      (equal 2 0)
      :value nil :explanation
      (different-atoms
       (2 "#x2" "?")
       (0 "#x0" "? "))))
   FAILED   5/13  FACE-count-tests
   passed   6/13  FACE-new-aesthetic-method-produced
   passed   7/13  FACE-new-aesthetic-produced
   passed   8/13  FACE-new-concept-method-produced
   passed   9/13  FACE-new-concept-produced
   passed  10/13  FACE-new-example-method-produced
   passed  11/13  FACE-new-example-produced
   passed  12/13  FACE-new-framing-method-produced
   passed  13/13  FACE-new-framing-produced

Ran 13 tests, 12 results as expected, 1 unexpected (2013-11-14 10:17:17+0000)

1 unexpected results:
   FAILED  FACE-count-tests

[master ea5daea] Lots more discussion and a couple more tests
 1 files changed, 72 insertions(+), 10 deletions(-)
~/test-driven-development $ git commit --help
WARNING: terminal is not fully functional
-  (press RETURN) 
GIT-COMMIT(1)                                            Git Manual                                           GIT-COMMIT(1)

NAME
       git-commit - Record changes to the repository

SYNOPSIS
       git commit [-a | --interactive] [-s] [-v] [-u<mode>] [--amend] [--dry-run]
                  [(-c | -C | --fixup | --squash) <commit>] [-F <file> | -m <msg>]
                  [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify]
                  [-e] [--author=<author>] [--date=<date>] [--cleanup=<mode>]
                  [--status | --no-status] [-i | -o] [--] [<file>...]

DESCRIPTION
       Stores the current contents of the index in a new commit along with a log message from the user describing the
       changes.

       The content to be added can be specified in several ways:

        1. by using git add to incrementally "add" changes to the index before using the commit command (Note: even
           modified files must be "added");

        2. by using git rm to remove files from the working tree and the index, again before using the commit command;

        3. by listing files as arguments to the commit command, in which case the commit will ignore changes staged in the
: 
           index, and instead record the current content of the listed files (which must already be known to git);

        4. by using the -a switch with the commit command to automatically "add" changes from all known files (i.e. all
           files that are already listed in the index) and to automatically "rm" files in the index that have been removed
           from the working tree, and then perform the actual commit;

        5. by using the --interactive switch with the commit command to decide one by one which files should be part of the
           commit, before finalizing the operation. Currently, this is done by invoking git add --interactive.

       The --dry-run option can be used to obtain a summary of what is included by any of the above for the next commit by
       giving the same set of parameters (options and paths).

       If you make a commit and then find a mistake immediately after that, you can recover from it with git reset.

OPTIONS
       -a, --all
           Tell the command to automatically stage files that have been modified and deleted, but new files you have not
           told git about are not affected.

       -C <commit>, --reuse-message=<commit>
           Take an existing commit object, and reuse the log message and the authorship information (including the
           timestamp) when creating the commit.

       -c <commit>, --reedit-message=<commit>
: 
           Like -C, but with -c the editor is invoked, so that the user can further edit the commit message.

       --fixup=<commit>
           Construct a commit message for use with rebase --autosquash. The commit message will be the subject line from
           the specified commit with a prefix of "fixup! ". See git-rebase(1) for details.

       --squash=<commit>
           Construct a commit message for use with rebase --autosquash. The commit message subject line is taken from the
           specified commit with a prefix of "squash! ". Can be used with additional commit message options (-m/-c/-C/-F).
           See git-rebase(1) for details.

       --reset-author
           When used with -C/-c/--amend options, declare that the authorship of the resulting commit now belongs of the
           committer. This also renews the author timestamp.

       --short
           When doing a dry-run, give the output in the short-format. See git-status(1) for details. Implies --dry-run.

       --porcelain
           When doing a dry-run, give the output in a porcelain-ready format. See git-status(1) for details. Implies
           --dry-run.

       -z
           When showing short or porcelain status output, terminate entries in the status output with NUL, instead of LF.
: 
           If no format is given, implies the --porcelain output format.

       -F <file>, --file=<file>
           Take the commit message from the given file. Use - to read the message from the standard input.

       --author=<author>
           Override the commit author. Specify an explicit author using the standard A U Thor <author@example.com[1]>
           format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that
           author (i.e. rev-list --all -i --author=<author>); the commit author is then copied from the first such commit
           found.

       --date=<date>
           Override the author date used in the commit.

       -m <msg>, --message=<msg>
           Use the given <msg> as the commit message.

       -t <file>, --template=<file>
           Use the contents of the given file as the initial version of the commit message. The editor is invoked and you
           can make subsequent changes. If a message is specified using the -m or -F options, this option has no effect.
           This overrides the commit.template configuration variable.

       -s, --signoff
           Add Signed-off-by line by the committer at the end of the commit log message.
: 

       -n, --no-verify
           This option bypasses the pre-commit and commit-msg hooks. See also githooks(5).

       --allow-empty
           Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command
           prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM
           interface scripts.

       --allow-empty-message
           Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a
           commit with an empty commit message without using plumbing commands like git-commit-tree(1).

       --cleanup=<mode>
           This option sets how the commit message is cleaned up. The <mode> can be one of verbatim, whitespace, strip, and
           default. The default mode will strip leading and trailing empty lines and #commentary from the commit message
           only if the message is to be edited. Otherwise only whitespace removed. The verbatim mode does not change
           message at all, whitespace removes just leading/trailing whitespace lines and strip removes both whitespace and
           commentary.

       -e, --edit
           The message taken from file with -F, command line with -m, and from file with -C are usually used as the commit
           log message unmodified. This option lets you further edit the message taken from these sources.
:
: 
       --amend
           Used to amend the tip of the current branch. Prepare the tree object you would want to replace the latest commit
           as usual (this includes the usual -i/-o and explicit paths), and the commit log editor is seeded with the commit
           message from the tip of the current branch. The commit you create replaces the current tip -- if it was a merge,
           it will have the parents of the current tip as parents -- so the current top commit is discarded.

           It is a rough equivalent for:

                       $ git reset --soft HEAD^
                       $ ... do something else to come up with the right tree ...
                       $ git commit -c ORIG_HEAD

           but can be used to amend a merge commit.

           You should understand the implications of rewriting history if you amend a commit that has already been
           published. (See the "RECOVERING FROM UPSTREAM REBASE" section in git-rebase(1).)

       -i, --include
           Before making a commit out of staged contents so far, stage the contents of paths given on the command line as
           well. This is usually not what you want unless you are concluding a conflicted merge.

       -o, --only
           Make a commit only from the paths specified on the command line, disregarding any contents that have been staged
           so far. This is the default mode of operation of git commit if any paths are given on the command line, in which
: 
           case this option can be omitted. If this option is specified together with --amend, then no paths need to be
           specified, which can be used to amend the last commit without committing changes that have already been staged.

       -u[<mode>], --untracked-files[=<mode>]
           Show untracked files.

           The mode parameter is optional (defaults to all), and is used to specify the handling of untracked files; when
           -u is not used, the default is normal, i.e. show untracked files and directories.

           The possible options are:

           o    no - Show no untracked files

           o    normal - Shows untracked files and directories

           o    all - Also shows individual files in untracked directories.

               The default can be changed using the status.showUntrackedFiles configuration variable documented in git-
               config(1).

       -v, --verbose
           Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message
           template. Note that this diff output doesn't have its lines prefixed with #.
:
: 
       -q, --quiet
           Suppress commit summary message.

       --dry-run
           Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be
           left uncommitted and paths that are untracked.

       --status
           Include the output of git-status(1) in the commit message template when using an editor to prepare the commit
           message. Defaults to on, but can be used to override configuration variable commit.status.

       --no-status
           Do not include the output of git-status(1) in the commit message template when using an editor to prepare the
           default commit message.

       --
           Do not interpret any more arguments as options.

       <file>...
           When files are given on the command line, the command commits the contents of the named files, without recording
           the changes already staged. The contents of these files are also staged for the next commit on top of what have
           been staged before.

DATE FORMATS
: 
       The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment variables and the --date option support the following date
       formats:

       Git internal format
           It is <unix timestamp> <timezone offset>, where <unix timestamp> is the number of seconds since the UNIX epoch.
           <timezone offset> is a positive or negative offset from UTC. For example CET (which is 2 hours ahead UTC) is
           +0200.

       RFC 2822
           The standard email format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.

       ISO 8601
           Time and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space
           instead of the T character as well.

               Note
               In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.

EXAMPLES
       When recording your own work, the contents of modified files in your working tree are temporarily stored to a
       staging area called the "index" with git add. A file can be reverted back, only in the index but not in the working
       tree, to that of the last commit with git reset HEAD -- <file>, which effectively reverts git add and prevents the
       changes to this file from participating in the next commit. After building the state to be committed incrementally
       with these commands, git commit (without any pathname parameter) is used to record what has been staged so far. This
: 
       is the most basic form of the command. An example:

           $ edit hello.c
           $ git rm goodbye.c
           $ git add hello.c
           $ git commit

       Instead of staging files after each individual change, you can tell git commit to notice the changes to the files
       whose contents are tracked in your working tree and do corresponding git add and git rm for you. That is, this
       example does the same as the earlier example if there is no other change in your working tree:

           $ edit hello.c
           $ rm goodbye.c
           $ git commit -a

       The command git commit -a first looks at your working tree, notices that you have modified hello.c and removed
       goodbye.c, and performs necessary git add and git rm for you.

       After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to git
       commit. When pathnames are given, the command makes a commit that only records the changes made to the named paths:

           $ edit hello.c hello.h
           $ git add hello.c hello.h
           $ edit Makefile
: 
           $ git commit Makefile

       This makes a commit that records the modification to Makefile. The changes staged for hello.c and hello.h are not
       included in the resulting commit. However, their changes are not lost -- they are still staged and merely held back.
       After the above sequence, if you do:

           $ git commit

       this second commit would record the changes to hello.c and hello.h as expected.

       After a merge (initiated by git merge or git pull) stops because of conflicts, cleanly merged paths are already
       staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check
       which paths are conflicting with git status and after fixing them manually in your working tree, you would stage the
       result as usual with git add:

           $ git status | grep unmerged
           unmerged: hello.c
           $ edit hello.c
           $ git add hello.c

       After resolving conflicts and staging the result, git ls-files -u would stop mentioning the conflicted path. When
       you are done, run git commit to finally record the merge:

           $ git commit
: 

       As with the case to record your own changes, you can use -a option to save typing. One difference is that during a
       merge resolution, you cannot use git commit with pathnames to alter the order the changes are committed, because the
       merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see -i
       option).

DISCUSSION
       Though not required, it's a good idea to begin the commit message with a single short (less than 50 character) line
       summarizing the change, followed by a blank line and then a more thorough description. Tools that turn commits into
       email, for example, use the first line on the Subject: line and the rest of the commit in the body.

       At the core level, git is character encoding agnostic.

       o   The pathnames recorded in the index and in the tree objects are treated as uninterpreted sequences of non-NUL
           bytes. What readdir(2) returns are what are recorded and compared with the data git keeps track of, which in
           turn are expected to be what lstat(2) and creat(2) accepts. There is no such thing as pathname encoding
           translation.

       o   The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the
           core level.

       o   The commit log messages are uninterpreted sequences of non-NUL bytes.

       Although we encourage that the commit log messages are encoded in UTF-8, both the core and git Porcelain are
: 
       designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use
       legacy encodings, git does not forbid it. However, there are a few things to keep in mind.

        1.  git commit and git commit-tree issues a warning if the commit log message given to it does not look like a
           valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to
           have i18n.commitencoding in .git/config file, like this:

               [i18n]
                       commitencoding = ISO-8859-1

           Commit objects created with the above setting record the value of i18n.commitencoding in its encoding header.
           This is to help other people who look at them later. Lack of this header implies that the commit log message is
           encoded in UTF-8.

        2.  git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the
           log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with
           i18n.logoutputencoding in .git/config file, like this:

               [i18n]
                       logoutputencoding = ISO-8859-1

           If you do not have this configuration variable, the value of i18n.commitencoding is used instead.

       Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the
: 
       commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.

ENVIRONMENT AND CONFIGURATION VARIABLES
       The editor used to edit the commit log message will be chosen from the GIT_EDITOR environment variable, the
       core.editor configuration variable, the VISUAL environment variable, or the EDITOR environment variable (in that
       order). See git-var(1) for details.

HOOKS
       This command can run commit-msg, prepare-commit-msg, pre-commit, and post-commit hooks. See githooks(5) for more
       information.

SEE ALSO
       git-add(1), git-rm(1), git-mv(1), git-merge(1), git-commit-tree(1)

AUTHOR
       Written by Linus Torvalds <torvalds@osdl.org[2]> and Junio C Hamano <gitster@pobox.com[3]>

GIT
       Part of the git(1) suite

NOTES
        1. author@example.com
           mailto:author@example.com
:
: 
        2. torvalds@osdl.org
           mailto:torvalds@osdl.org

        3. gitster@pobox.com
           mailto:gitster@pobox.com

Git 1.7.4.3                                              04/03/2011                                           GIT-COMMIT(1)
(END) q
~/test-driven-development $ ~/test-driven-development $ man git-rebase
WARNING: terminal is not fully functional
-  (press RETURN) 
GIT-REBASE(1)                                            Git Manual                                           GIT-REBASE(1)

NAME
       git-rebase - Forward-port local commits to the updated upstream head

SYNOPSIS
       git rebase [-i | --interactive] [options] [--onto <newbase>]
               <upstream> [<branch>]
       git rebase [-i | --interactive] [options] --onto <newbase>
               --root [<branch>]

       git rebase --continue | --skip | --abort

DESCRIPTION
       If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing anything else.
       Otherwise it remains on the current branch.

       All changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area. This
       is the same set of commits that would be shown by git log <upstream>..HEAD (or git log HEAD, if --root is
       specified).

       The current branch is reset to <upstream>, or <newbase> if the --onto option was supplied. This has the exact same
       effect as git reset --hard <upstream> (or <newbase>). ORIG_HEAD is set to point at the tip of the branch before the
       reset.
: 

       The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one,
       in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..<upstream> are
       omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).

       It is possible that a merge failure will prevent this process from being completely automatic. You will have to
       resolve any such merge failure and run git rebase --continue. Another option is to bypass the commit that caused the
       merge failure with git rebase --skip. To restore the original <branch> and remove the .git/rebase-apply working
       files, use the command git rebase --abort instead.

       Assume the following history exists and the current branch is "topic":

                     A---B---C topic
                    /
               D---E---F---G master

       From this point, the result of either of the following commands:

           git rebase master
           git rebase master topic

       would be:

                             A'--B'--C' topic
: 
                            /
               D---E---F---G master

       The latter form is just a short-hand of git checkout topic followed by git rebase master.

       If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied
       upstream), then that commit will be skipped. For example, running `git rebase master` on the following history (in
       which A' and A introduce the same set of changes, but have different committer information):

                     A---B---C topic
                    /
               D---E---A'---F master

       will result in:

                              B'---C' topic
                             /
               D---E---A'---F master

       Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic
       branch from the latter branch, using rebase --onto.

       First let's assume your topic is based on branch next. For example, a feature developed in topic depends on some
       functionality which is found in next.
: 

               o---o---o---o---o  master
                    \
                     o---o---o---o---o  next
                                      \
                                       o---o---o  topic

       We want to make topic forked from branch master; for example, because the functionality on which topic depends was
       merged into the more stable master branch. We want our tree to look like this:

               o---o---o---o---o  master
                   |            \
                   |             o'--o'--o'  topic
                    \
                     o---o---o---o---o  next

       We can get this using the following command:

           git rebase --onto master next topic

       Another example of --onto option is to rebase part of a branch. If we have the following situation:

                                       H---I---J topicB
                                      /
: 
                             E---F---G  topicA
                            /
               A---B---C---D  master

       then the command

           git rebase --onto master topicA topicB

       would result in:

                            H'--I'--J'  topicB
                           /
                           | E---F---G  topicA
                           |/
               A---B---C---D  master

       This is useful when topicB does not depend on topicA.

       A range of commits could also be removed with rebase. If we have the following situation:

               E---F---G---H---I---J  topicA

       then the command
:
: 
           git rebase --onto topicA~5 topicA~3 topicA

       would result in the removal of commits F and G:

               E---H'---I'---J'  topicA

       This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto
       and the <upstream> parameter can be any valid commit-ish.

       In case of conflict, git rebase will stop at the first problematic commit and leave conflict markers in the tree.
       You can use git diff to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit,
       you need to tell git that the conflict has been resolved, typically this would be done with

           git add <filename>

       After resolving the conflict manually and updating the index with the desired resolution, you can continue the
       rebasing process with

           git rebase --continue

       Alternatively, you can undo the git rebase with

           git rebase --abort
:
: 
CONFIGURATION
       rebase.stat
           Whether to show a diffstat of what changed upstream since the last rebase. False by default.

       rebase.autosquash
           If set to true enable --autosquash option by default.

OPTIONS
       <newbase>
           Starting point at which to create the new commits. If the --onto option is not specified, the starting point is
           <upstream>. May be any valid commit, and not just an existing branch name.

           As a special case, you may use "A...B" as a shortcut for the merge base of A and B if there is exactly one merge
           base. You can leave out at most one of A and B, in which case it defaults to HEAD.

       <upstream>
           Upstream branch to compare against. May be any valid commit, not just an existing branch name.

       <branch>
           Working branch; defaults to HEAD.

       --continue
           Restart the rebasing process after having resolved a merge conflict.
:
: 
       --abort
           Restore the original branch and abort the rebase operation.

       --skip
           Restart the rebasing process by skipping the current patch.

       -m, --merge
           Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be
           aware of renames on the upstream side.

           Note that a rebase merge works by replaying each commit from the working branch on top of the <upstream> branch.
           Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting
           with <upstream>, and theirs is the working branch. In other words, the sides are swapped.

       -s <strategy>, --strategy=<strategy>
           Use the given merge strategy. If there is no -s option git merge-recursive is used instead. This implies
           --merge.

           Because git rebase replays each commit from the working branch on top of the <upstream> branch using the given
           strategy, using the ours strategy simply discards all patches from the <branch>, which makes little sense.

       -X <strategy-option>, --strategy-option=<strategy-option>
           Pass the <strategy-option> through to the merge strategy. This implies --merge and, if no strategy has been
           specified, -s recursive. Note the reversal of ours and theirs as noted in above for the -m option.
: 

       -q, --quiet
           Be quiet. Implies --no-stat.

       -v, --verbose
           Be verbose. Implies --stat.

       --stat
           Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the
           configuration option rebase.stat.

       -n, --no-stat
           Do not show a diffstat as part of the rebase process.

       --no-verify
           This option bypasses the pre-rebase hook. See also githooks(5).

       --verify
           Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See
           also githooks(5).

       -C<n>
           Ensure at least <n> lines of surrounding context match before and after each change. When fewer lines of
           surrounding context exist they all must match. By default no context is ever ignored.
: 

       -f, --force-rebase
           Force the rebase even if the current branch is a descendant of the commit you are rebasing onto. Normally
           non-interactive rebase will exit with the message "Current branch is up to date" in such a situation.
           Incompatible with the --interactive option.

           You may find this (or --no-ff with an interactive rebase) helpful after reverting a topic branch merge, as this
           option recreates the topic branch with fresh commits so it can be remerged successfully without needing to
           "revert the reversion" (see the revert-a-faulty-merge How-To[1] for details).

       --ignore-whitespace, --whitespace=<option>
           These flag are passed to the git apply program (see git-apply(1)) that applies the patch. Incompatible with the
           --interactive option.

       --committer-date-is-author-date, --ignore-date
           These flags are passed to git am to easily change the dates of the rebased commits (see git-am(1)). Incompatible
           with the --interactive option.

       -i, --interactive
           Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode
           can also be used to split commits (see SPLITTING COMMITS below).

       -p, --preserve-merges
           Instead of ignoring merges, try to recreate them.
: 

           This uses the --interactive machinery internally, but combining it with the --interactive option explicitly is
           generally not a good idea unless you know what you are doing (see BUGS below).

       --root
           Rebase all commits reachable from <branch>, instead of limiting them with an <upstream>. This allows you to
           rebase the root commit(s) on a branch. Must be used with --onto, and will skip changes already contained in
           <newbase> (instead of <upstream>). When used together with --preserve-merges, all root commits will be rewritten
           to have <newbase> as parent instead.

       --autosquash, --no-autosquash
           When the commit log message begins with "squash! ..." (or "fixup! ..."), and there is a commit whose title
           begins with the same ..., automatically modify the todo list of rebase -i so that the commit marked for
           squashing comes right after the commit to be modified, and change the action of the moved commit from pick to
           squash (or fixup).

           This option is only valid when the --interactive option is used.

           If the --autosquash option is enabled by default using the configuration variable rebase.autosquash, this option
           can be used to override and disable this setting.

       --no-ff
           With --interactive, cherry-pick all rebased commits instead of fast-forwarding over the unchanged ones. This
           ensures that the entire history of the rebased branch is composed of new commits.
: 

           Without --interactive, this is a synonym for --force-rebase.

           You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with
           fresh commits so it can be remerged successfully without needing to "revert the reversion" (see the
           revert-a-faulty-merge How-To[1] for details).

MERGE STRATEGIES
       The merge mechanism (git-merge and git-pull commands) allows the backend merge strategies to be chosen with -s
       option. Some strategies can also take their own options, which can be passed by giving -X<option> arguments to
       git-merge and/or git-pull.

       resolve
           This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge
           algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.

       recursive
           This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that
           can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference
           tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mis-merges
           by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can
           detect and handle merges involving renames. This is the default merge strategy when pulling or merging one
           branch.
:
: 
           The recursive strategy can take the following options:

           ours
               This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the
               other tree that do not conflict with our side are reflected to the merge result.

               This should not be confused with the ours merge strategy, which does not even look at what the other tree
               contains at all. It discards everything the other tree did, declaring our history contains all that happened
               in it.

           theirs
               This is opposite of ours.

           patience
               With this option, merge-recursive spends a little extra time to avoid mismerges that sometimes occur due to
               unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged
               have diverged wildly. See also git-diff(1) --patience.

           ignore-space-change, ignore-all-space, ignore-space-at-eol
               Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge.
               Whitespace changes mixed with other changes to a line are not ignored. See also git-diff(1) -b, -w, and
               --ignore-space-at-eol.

               o   If their version only introduces whitespace changes to a line, our version is used;
: 

               o   If our version introduces whitespace changes but their version includes a substantial change, their
                   version is used;

               o   Otherwise, the merge proceeds in the usual way.

           renormalize
               This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge.
               This option is meant to be used when merging branches with different clean filters or end-of-line
               normalization rules. See "Merging branches with differing checkin/checkout attributes" in gitattributes(5)
               for details.

           no-renormalize
               Disables the renormalize option. This overrides the merge.renormalize configuration variable.

           rename-threshold=<n>
               Controls the similarity threshold used for rename detection. See also git-diff(1) -M.

           subtree[=<path>]
               This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees
               must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped
               from the beginning) to make the shape of two trees to match.

       octopus
: 
           This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It
           is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when
           pulling or merging more than one branch.

       ours
           This resolves any number of heads, but the resulting tree of the merge is always that of the current branch
           head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old
           development history of side branches. Note that this is different from the -Xours option to the recursive merge
           strategy.

       subtree
           This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is
           first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment
           is also done to the common ancestor tree.

NOTES
       You should understand the implications of using git rebase on a repository that you share. See also RECOVERING FROM
       UPSTREAM REBASE below.

       When the git-rebase command is run, it will first execute a "pre-rebase" hook if one exists. You can use this hook
       to do sanity checks and reject the rebase if it isn't appropriate. Please see the template pre-rebase hook script
       for an example.

       Upon completion, <branch> will be the current branch.
: 

INTERACTIVE MODE
       Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the
       commits, and you can remove them (weeding out bad or otherwise unwanted patches).

       The interactive mode is meant for this type of workflow:

        1. have a wonderful idea

        2. hack on the code

        3. prepare a series for submission

        4. submit

       where point 2. consists of several instances of

        1. regular use

            1. finish something worthy of a commit

            2. commit

        2. independent fixup
: 

            1. realize that something does not work

            2. fix that

            3. commit it

       Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is
       buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of "a"s and
       "b"s, by rearranging and editing commits, and squashing multiple commits into one.

       Start it with the last commit you want to retain as-is:

           git rebase -i <after-this-commit>

       An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after
       the given commit. You can reorder the commits in this list to your heart's content, and you can remove them. The
       list looks more or less like this:

           pick deadbee The oneline of this commit
           pick fa1afe1 The oneline of the next commit
           ...

       The oneline descriptions are purely for your pleasure; git rebase will not look at them but at the commit names
: 
       ("deadbee" and "fa1afe1" in this example), so do not delete or edit the names.

       By replacing the command "pick" with the command "edit", you can tell git rebase to stop after applying that commit,
       so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.

       If you just want to edit the commit message for a commit, replace the command "pick" with the command "reword".

       If you want to fold two or more commits into one, replace the command "pick" for the second and subsequent commits
       with "squash" or "fixup". If the commits had different authors, the folded commit will be attributed to the author
       of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages
       of the first commit and of those with the "squash" command, but omits the commit messages of commits with the
       "fixup" command.

       git rebase will stop when "pick" has been replaced with "edit" or when a command fails due to merge errors. When you
       are done editing and/or resolving conflicts you can continue with git rebase --continue.

       For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve
       that, you would call git rebase like this:

           $ git rebase -i HEAD~5

       And move the first patch to the end of the list.

       You might want to preserve merges, if you have a history like this:
: 

                      X
                       \
                    A---M---B
                   /
           ---o---O---P---Q

       Suppose you want to rebase the side branch starting at "A" to "Q". Make sure that the current HEAD is "B", and call

           $ git rebase -i -p --onto Q O

       Reordering and editing commits usually creates untested intermediate steps. You may want to check that your history
       editing did not break anything by running a test, or at least recompiling at intermediate points in history by using
       the "exec" command (shortcut "x"). You may do so by creating a todo list like this one:

           pick deadbee Implement feature XXX
           fixup f1a5c00 Fix to feature XXX
           exec make
           pick c0ffeee The oneline of the next commit
           edit deadbab The oneline of the commit after
           exec cd subdir; make test
           ...

       The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to
: 
       fix the problem. You can continue with git rebase --continue.

       The "exec" command launches the command in a shell (the one specified in $SHELL, or the default shell if $SHELL is
       not set), so you can use shell features (like "cd", ">", ";" ...). The command is run from the root of the working
       tree.

SPLITTING COMMITS
       In interactive mode, you can mark commits with the action "edit". However, this does not necessarily mean that git
       rebase expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add
       other commits. This can be used to split a commit into two:

       o   Start an interactive rebase with git rebase -i <commit>^, where <commit> is the commit you want to split. In
           fact, any commit range will do, as long as it contains that commit.

       o   Mark the commit you want to split with the action "edit".

       o   When it comes to editing that commit, execute git reset HEAD^. The effect is that the HEAD is rewound by one,
           and the index follows suit. However, the working tree stays the same.

       o   Now add the changes to the index that you want to have in the first commit. You can use git add (possibly
           interactively) or git gui (or both) to do that.

       o   Commit the now-current index with whatever commit message is appropriate now.
:
: 
       o   Repeat the last two steps until your working tree is clean.

       o   Continue the rebase with git rebase --continue.

       If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite,
       etc.) you should use git stash to stash away the not-yet-committed changes after each commit, test, and amend the
       commit if fixes are necessary.

RECOVERING FROM UPSTREAM REBASE
       Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream
       of it is forced to manually fix their history. This section explains how to do the fix from the downstream's point
       of view. The real fix, however, would be to avoid rebasing the upstream in the first place.

       To illustrate, suppose you are in a situation where someone develops a subsystem branch, and you are working on a
       topic that is dependent on this subsystem. You might end up with a history like the following:

               o---o---o---o---o---o---o---o---o  master
                    \
                     o---o---o---o---o  subsystem
                                      \
                                       *---*---*  topic

       If subsystem is rebased against master, the following happens:
:
: 
               o---o---o---o---o---o---o---o  master
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                                      \
                                       *---*---*  topic

       If you now continue development as usual, and eventually merge topic to subsystem, the commits from subsystem will
       remain duplicated forever:

               o---o---o---o---o---o---o---o  master
                    \                       \
                     o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                                      \                         /
                                       *---*---*-..........-*--*  topic

       Such duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean
       things up, you need to transplant the commits on topic to the new subsystem tip, i.e., rebase topic. This becomes a
       ripple effect: anyone downstream from topic is forced to rebase too, and so on!

       There are two kinds of fixes, discussed in the following subsections:

       Easy case: The changes are literally the same.
           This happens if the subsystem rebase was a simple rebase and had no conflicts.
:
: 
       Hard case: The changes are not the same.
           This happens if the subsystem rebase had conflicts, or used --interactive to omit, edit, squash, or fixup
           commits; or if the upstream used one of commit --amend, reset, or filter-branch.

   The easy case
       Only works if the changes (patch IDs based on the diff contents) on subsystem are literally the same before and
       after the rebase subsystem did.

       In that case, the fix is easy because git rebase knows to skip changes that are already present in the new upstream.
       So if you say (assuming you're on topic)

               $ git rebase subsystem

       you will end up with the fixed history

               o---o---o---o---o---o---o---o  master
                                            \
                                             o'--o'--o'--o'--o'  subsystem
                                                              \
                                                               *---*---*  topic

   The hard case
       Things get more complicated if the subsystem changes do not exactly correspond to the ones before the rebase.
:
: 
           Note
           While an "easy case recovery" sometimes appears to be successful even in the hard case, it may have unintended
           consequences. For example, a commit that was removed via git rebase --interactive will be resurrected!

       The idea is to manually tell git rebase "where the old subsystem ended and your topic began", that is, what the old
       merge-base between them was. You will have to find a way to name the last commit of the old subsystem, for example:

       o   With the subsystem reflog: after git fetch, the old tip of subsystem is at subsystem@{1}. Subsequent fetches
           will increase the number. (See git-reflog(1).)

       o   Relative to the tip of topic: knowing that your topic has three commits, the old tip of subsystem must be
           topic~3.

       You can then transplant the old subsystem..topic to the new tip by saying (for the reflog case, and assuming you are
       on topic already):

               $ git rebase --onto subsystem subsystem@{1}

       The ripple effect of a "hard case" recovery is especially bad: everyone downstream from topic will now have to
       perform a "hard case" recovery too!

BUGS
       The todo list presented by --preserve-merges --interactive does not represent the topology of the revision graph.
       Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to
: 
       produce counterintuitive results.

       For example, an attempt to rearrange

           1 --- 2 --- 3 --- 4 --- 5

       to

           1 --- 2 --- 4 --- 3 --- 5

       by moving the "pick 4" line will result in the following history:

                   3
                  /
           1 --- 2 --- 4 --- 5

AUTHORS
       Written by Junio C Hamano <gitster@pobox.com[2]> and Johannes E. Schindelin <johannes.schindelin@gmx.de[3]>

DOCUMENTATION
       Documentation by Junio C Hamano and the git-list <git@vger.kernel.org[4]>.

GIT
       Part of the git(1) suite
: 

NOTES
        1. revert-a-faulty-merge How-To
           http://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt

        2. gitster@pobox.com
           mailto:gitster@pobox.com

        3. johannes.schindelin@gmx.de
           mailto:johannes.schindelin@gmx.de

        4. git@vger.kernel.org
           mailto:git@vger.kernel.org

Git 1.7.4.3                                              04/03/2011                                           GIT-REBASE(1)
(END) q
~/test-driven-development $ ~/test-driven-development $ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	have-a-look
#	have-a-look~
#	post-commit-orig
#	test-driven-development.el~
nothing added to commit but untracked files present (use "git add" to track)
~/test-driven-development $ rm have-a-look
~/test-driven-development $ rm have-a-look~
~/test-driven-development $ rm post-commit-orig
~/test-driven-development $ rm test-driven-development.el~
~/test-driven-development $ ls
README  post-commit  test-driven-development.el
~/test-driven-development $ git status
# On branch master
nothing to commit (working directory clean)
~/test-driven-development $ cd
~ $ pandoc --from=markdown --to=html notes.md
<h1 id="documentation-general-overview">Documentation: General Overview:</h1>
<p>The idea in this file is to use some variant of test driven development (for now, within the framework describe in ~/emacs-24.3/info/ert.info) as a way to keep track of an evolving model of a codebase. It is build around a set of tests that instantiate the FACE model of computational creativity. This model is specified, at the outline level, as follows:</p>
<p><code>F = framing A = aesthetic C = concept E = Example / Expression (?)</code></p>
<h1 id="potential-uses-of-this-system">Potential uses of this system:</h1>
<ul>
<li><p>In a given instantiation of this programme, we might model something like the growth of the APM XI corpus through the addition of new examples and new relationships between elements.</p></li>
<li><p>In general, like with other kinds of test-driven development, we might write the tests &quot;first&quot; and use these to specify objectives as a &quot;development roadmap&quot; i.e. when those tests are passing, a given phase of the project is complete.</p></li>
</ul>
<p>Note that it seems vastly easier to build a particular instantiation of the FACE model than it is to build a general-purpose test that would always say &quot;you have added a new concept&quot; or &quot;you have added a new aesthetic-method&quot;.</p>
<p>Instead of having a fully general model that works every time, we could instead come up with a type-theoretic treatment of the FACE schema, so that we could check whether a given system implements a test for a given facet of FACE.</p>
<p>If we go that route, it might make more sense to implement the test system in Haskell rather than LISP... but of course we actually want to be flexible, so we need to maintain a general sense of a test &quot;implementing&quot; a given type of test, across different programming languages - eventually, what we could provide in the COINVENT project is a set of sample implementations in various languages, together with an API for reporting/logging progress. In order to make this attractive to potential users (and generate some empirical data) we might want to have a computational creativity contest.</p>
<p>From a philosophical point of view, note that simply creating more and more concepts probably isn't the most &quot;creative&quot; -- actually, defining (and passing) new tests which get at different facets of creativity would tend to improve the overall &quot;score&quot;. Maybe each new test should be treated as a &quot;multiplier&quot; or something.</p>
<p>From a procedural point of view, the system should, accordingly, work on several levels:</p>
<ul>
<li><p>A test that can detect when e.g. a new framing has been produced by looking for new documentation strings or whatever else qualifies as a &quot;framing&quot;.</p></li>
<li><p>A test that can detect when a new <em>test</em> has been written, E.g. in addition to documentation strings, suppose we define a new kind of framing object called a &quot;walkthrough&quot;, and we will consider a new framing to have been produced whenever either a new doc string or a new walkthrough is produced. In the first place, we need to note the existence of the walkthrough test.</p></li>
</ul>
<p>&quot;Tests&quot; themselves could be considered to be concepts or perhaps aesthetics (typically they map into {0,1}, but in general they could map to a set of error codes).</p>
<p>Note also that the tests generally need to be applied to the &quot;increment&quot;, for instance, all <em>new</em> code that has been written since the last commit. So, we need a method for extracting this increment. I did something similar in my thesis that analysed git logs and looked for named entities in the diffs. Extracting a meaningful piece of code <em>directly</em> from a line-diff is not always going to be possible, since adding a single line typically isn't a &quot;semantically&quot; meaningful change.</p>
<blockquote>
<p>Making our diffs more semantic is an obvious thing to fix.</p>
</blockquote>
<p>Let's assume that we can get ahold of the semantically meaningful changes with a little bit of code that scans a git commit and then reads the corresponding file. Then we need to analyse this new code with the available tests -- and maybe, for user-friendly record-keeping, update the commit message automatically with a tally. All of this git stuff is a fairly specific implementation detail.</p>
<p>We could start with something simpler, like identifying the number of <code>defun' and</code>defvar' usages in a given file. It's not entirely clear that the `ert-deftest' mechanism will be the best way to go, rather than using some other ad hoc code scanning and reporting mechanism, but we can try!</p>
<blockquote>
<p>After a first pass, I can see that ERT does work, but the reporting mechanism isn't quite aligned with what we want to do, so after a prototyping phase, it would be nice to augment ERT with some more &quot;qualitative&quot; reporting mechanisms.</p>
</blockquote>
<p>The ERT documentation says &quot;ERT only provides explanations for predicates that have an explanation function registered.&quot; But for now, explanations are only triggered when a test fails, so the intuitive logic in the prototype is &quot;reversed&quot;, i.e. &quot;failing&quot; is good, because it produces explanations.</p>
<p>They also say:</p>
<blockquote>
<p>ERT does not have built-in support for mocks or stubs. The package <code>el-mock' (see</code>http://www.emacswiki.org/emacs/el-mock.el') offers mocks for Emacs Lisp and can be used in conjunction with ERT.</p>
</blockquote>
<p>Potentially worth checking this out when we get to the point of implementing a proper type theoretic schema.</p>
<h1 id="documentation-implementation-plan">Documentation: Implementation plan:</h1>
<p>The code in the ert-x package includes a macro for running tests on the current buffer, called `ert-with-buffer-renamed'. In theory, we could use this to test how many matches for a given regexp are present in the buffer, say. The one issue here is figuring out how to get ERT to report something qualitative, other than just pass/fail.</p>
<p>We have a sort of cheap method of doing that now, in the section &quot;Implement a cheap counting test&quot;.</p>
<p>We can have the code take in an &quot;increment&quot; to scan, see &quot;Pass in an increment&quot;</p>
<p>We can run all of the tests on a selected increment, see &quot;Run a battery of tests on a given file&quot;.</p>
<p>Next up, we would want to do a bit of &quot;model selection&quot;, i.e. check which of the 8 possible tests are actually implemented, and run only those. Although actually there are 8 <em>types</em> of test, and not just 8 tests. Maybe if I take out the &quot;shoulds&quot; the tests will automatically pass? Yes, that's true. So, this way I will only see reporting on the tests that are actually implemented.</p>
<p>It seems like I might as well just go ahead and implement this in ONE case (e.g. the APMXI case) and then I can take another pass to implement it in a more general type theoretic way.</p>
<p>[...]</p>
<p>Develop a nicer reporting framework so that we're not just seeing a bunch of failed tests, but instead, a nice-looking summary. Note that this is not separate from the type theoretic issues - we want to have a &quot;score card&quot; for each increment.</p>
<h1 id="documentation-comments-on-first-working-prototype">Documentation: Comments on first working prototype:</h1>
<p>I now have a prototype that can run tests non-interactively on the incremental changes in a git repository, using the git post-commit hook. As I mentioned just above, it would be nice to have a somewhat better reporting mechanism, and to then alter the commit messages by sticking relevant &quot;score card&quot; information into them. This is eminently doable.</p>
<p>For now the &quot;interesting things we can notice&quot; are defined in a rather simplistic way, since we only notice a few regexps that describe the creation of defuns and similar. However, this is already a usable start, i.e. I can easily make some tests that notice things of interest in hcode (e.g. defthm instead of deftest; I'll have to take a look at my old notes to see what's there).</p>
<p>The thing I'm thinking is: actually, just creating more and more definitions -- at least in this manner -- is not particularly creative. On one level it might be &quot;more creative&quot; to do a lot of them (as with a big translation effort) and ultimately when very many definitions are known, it would be creative to add something truly new. However, one might expect a very long non-creative interlude in the middle, where we just transcribe things from lots and lots of known sources. Clearly there would be <em>some</em> elements of creativity in this process, however: having to do in this case with inventive forms of transcription or translation, with interesting speed-ups and so forth.</p>
<p>But the basic point is that creativity is only really defined relative to an &quot;edge&quot;. Once we've done that thing before, or a lot of things like it, then another iteration of the same is not particularly creative.</p>
<p>Continuing this idea, do we want to count &quot;new&quot; appearances of <code>defn</code> or <code>defthm</code> as truly new concepts, if they have simply been transcribed from somewhere else? (If so, we'll have to do a little more integration work to describe how one test triggers recognition for another test.)</p>
~ $ 